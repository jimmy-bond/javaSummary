### 雪花算法

生成64bit的long数据值，组成有时间戳，所以可以保证生成的id自增

### Builder模式

Builder 模式作用域：**如果类的属性之间有一定的依赖关系或者约束条件（源自设计模式之美）**，那么就可以考虑使用 Builder 设计模式。

就像线程池的例子**构造器函数过多以及属性之间存在依赖关系和约束条件**。<img src="../../../AppData/Roaming/Typora/typora-user-images/image-20240704155514017.png" alt="image-20240704155514017" style="zoom: 50%;" />

**Hutool如何使用Builder模式创建线程池**

![image-20240704163348256](../../../AppData/Roaming/Typora/typora-user-images/image-20240704163348256.png)

create（）返回的是ExecutorBuilder的本身，这样才可以设置属性。

### 责任链模式

有两种处理方式：

1. 请求会被 **所有的处理器都处理一遍，不存在中途终止的情况**，这里参照 MyBatis 拦截器理解。
2. 二则是处理器链执行请求中，某一处理器执行时，**如果不符合自制定规则的话，停止流程，并且剩下未执行处理器就不会被执行**，大家参照 SpringMvc 拦截器理解。就像定义的token拦截器

还要考虑处理器的先后调用顺序

设计模式的开闭原则：添加一个功能时应该在原有代码中扩展而不是修改已有代码

#### Mybatis Interceptor 底层实现

![image-20240704170651367](../../../AppData/Roaming/Typora/typora-user-images/image-20240704170651367.png)

有处理器集合 interceptors，有添加处理器方法。

如果定义了多个查询相关的拦截器，会先经过拦截器的代码加工，所有的拦截器执行完毕后才会走真正查询数据库操作

![img](https://cdn.nlark.com/yuque/0/2022/png/331027/1672475031790-75313119-9dd0-4398-a7b1-12e92ee3349b.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_43%2Ctext_5pCc77yabmFnZW9mZmVyLmNvbQ%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

责任链模式的核心是一个链式结构，节点为handler，如果当前节点能够处理请求直接返回，否则请求前往下一个对象。直到找到能够处理的节点。

真实业务场景

如果这样设计代码会显得代码块十分臃肿

~~~java
public String createOrder(CreateOrderReqDTO xxx) {
    // 检查商品信息是否存在，包括商品名称、价格、规格等信息
  	// 检查购买数量是否合法，是否超出了最大购买数量或最小购买数量的限制
    // 检查商品库存是否充足，以确保库存足够满足购买者的需求
    // 检查购买者的优惠券、积分等是否可以使用，以确保购买者能够享受相应的优惠或积分奖励
    // 检查收货地址信息是否完整和准确，以确保商品能够顺利地送达给购买者
    // 检查下单时间是否合法，例如检查购买者是否在限定的时间范围内下单
    // ......
}
~~~

可以进行责任链重构

定义一个责任链处理接口

~~~java
public interface OrderCreateChainHandler<T> extends Ordered {
    
    /**
     * 执行责任链逻辑
     *
     * @param requestParam 责任链执行入参
     */
    void handler(T requestParam);
}
~~~

创建一个责任链的上下文容器

~~~java
public final class OrderCreateChainContext<T> implements CommandLineRunner {
    //静态类
    private final List<OrderCreateChainHandler> orderCreateChainHandlerContainer = new ArrayList();
    
    /**
     * 责任链组件执行
     *
     * @param requestParam 请求参数
     */
    public void handler(T requestParam) {
        // 此处根据 Ordered 实际值进行排序处理
        orderCreateChainHandlerContainer.stream()
                .sorted(Comparator.comparing(Ordered::getOrder)).forEach(each -> each.handler(requestParam));
    }
    
    //这一步先获取所有的处理链对象的类
    //并把它们放入上下文容器（静态，全局对象）当中
    @Override
    public void run(String... args) throws Exception {
      	// 通过 Spring 上下文容器，获取所有 CreateOrderChainContext Bean
        Map<String, OrderCreateChainHandler> chainFilterMap = ApplicationContextHolder.getBeansOfType(OrderCreateChainHandler.class);
      	// 将对应 Bean 放入责任链上下文容器中
        chainFilterMap.forEach((beanName, bean) -> orderCreateChainHandlerContainer.add(bean););
    }
~~~

实现 `OrderCreateChainHandler` 接口作为责任链处理器，每个具体的实现类负责执行特定的逻辑。

~~~java
// 订单创建参数必填检验
@Component
public final class OrderCreateParamNotNullChainHandler implements OrderCreateChainHandler<OrderCreateCommand> {
    
    @Override
    public void handler(OrderCreateCommand requestParam) {
	    // 逻辑执行
    }
    
    @Override
    public int getOrder() {
        return 0;
    }
}

// 订单创建参数正确性检验
@Component
public final class OrderCreateParamVerificationChainHandler implements OrderCreateChainHandler<OrderCreateCommand> {
    
    @Override
    public void handler(OrderCreateCommand requestParam) {
	    // 逻辑执行
    }
    
    @Override
    public int getOrder() {
        return 1;
    }
}
~~~

这样责任链就基本完成

##### 责任链进一步优化---责任类抽象

将OrderCreateChainHandler` 以及 `OrderCreateChainContext抽象出来，减少代码冗余量

###### OrderCreateChainHandler的抽象

~~~java
public interface AbstractChainHandler<T> extends Ordered {
    
    /**
     * 执行责任链逻辑
     *
     * @param requestParam 责任链执行入参
     */
    void handler(T requestParam);
    
    /**
     * @return 责任链组件标识
     */
    String mark();
}
~~~



mark（）用来分组——假设项目中有两个业务场景：订单下单和用户创建都需要责任链模式去验证，`mark` 就是用来进行分组

###### OrderCreateChainContext的抽象

~~~java
public final class AbstractChainContext<T> implements CommandLineRunner {
    
    private final Map<String, List<AbstractChainHandler>> abstractChainHandlerContainer = Maps.newHashMap();
    
    /**
     * 责任链组件执行
     *
     * @param requestParam 请求参数
     */
    public void handler(String mark, T requestParam) {
        abstractChainHandlerContainer.get(mark).stream()
                .sorted(Comparator.comparing(Ordered::getOrder)).forEach(each -> each.handler(requestParam));
    }
    
    @Override
    public void run(String... args) throws Exception {
        // 获取 Spring IOC 容器中所有 AbstractChainHandler 接口实现
        Map<String, AbstractChainHandler> chainFilterMap = ApplicationContextHolder.getBeansOfType(AbstractChainHandler.class);
        chainFilterMap.forEach((beanName, bean) -> {
            List<AbstractChainHandler> abstractChainHandlers = abstractChainHandlerContainer.get(bean.mark());
            if (abstractChainHandlers == null) {
                abstractChainHandlers = new ArrayList();
            }
            abstractChainHandlers.add(bean);
            // 根据 mark 标识将责任链模式分类，放入责任链容器上下文中
            abstractChainHandlerContainer.put(bean.mark(), abstractChainHandlers);
        });
    }
}
~~~

###### 抽象业务接口

~~~java
// 订单创建责任链过滤器
public interface OrderCreateChainFilter<T extends OrderCreateCommand> extends AbstractChainHandler<OrderCreateCommand> {
    
    //因为同一类责任链的Mark返回结果是相同的，所以就可以抽象出来
    @Override
    default String mark() {
        return OrderChainMarkEnum.ORDER_CREATE_FILTER.name();
    }
}
~~~

责任链子类的编写

~~~java
// 订单创建参数必填检验
@Component
public final class OrderCreateParamNotNullChainHandler implements OrderCreateChainFilter<OrderCreateCommand> {
    
    @Override
    public void handler(OrderCreateCommand requestParam) {
    	// 逻辑执行
    }
    
    @Override
    public int getOrder() {
        return 0;
    }
}
~~~

### 策略模式

