## 后台用户管理

### 异常码设计

异常码分为3种

A 表示用户端

B 表示客户端

C 表示第三方服务

错误码设计，去实现这个接口

~~~java
public interface IErrorCode {
    //错误码
     
    String code();
	// 错误信息
    String message();
}
~~~

![image-20240428115457668](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240428115457668.png)

### 异常设计

<img src="C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240428115851366.png" alt="image-20240428115851366" style="zoom:67%;" />

客户端，服务端等都继承

~~~java
//抽象归约异常
public abstract class AbstractException extends RuntimeException {

    public final String errorCode;

    public final String errorMessage;

    public AbstractException(String message, Throwable throwable, IErrorCode errorCode) {
        super(message, throwable);
        this.errorCode = errorCode.code();
        this.errorMessage = Optional.ofNullable(StringUtils.hasLength(message) ? message : null).orElse(errorCode.message());
    }
}
~~~

### 全局异常拦截器

![image-20240428121036005](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240428121036005.png)

@RestControllerAdvice用于统一处理这些类中抛出的异常，并对返回的数据进行统一处理。

![image-20240428121353996](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240428121353996.png)

拦截指定的异常

~~~java
 @ExceptionHandler(value = {AbstractException.class})
    public Result abstractException(HttpServletRequest request, AbstractException ex) {
       //具体输出ex抛出的异常信息
        if (ex.getCause() != null) {
            log.error("[{}] {} [ex] {}", request.getMethod(), request.getRequestURL().toString(), ex.toString(), ex.getCause());
            return Results.failure(ex);
        }
        log.error("[{}] {} [ex] {}", request.getMethod(), request.getRequestURL().toString(), ex.toString());
        return Results.failure(ex);
    }
~~~

### 全局统一返回实体

~~~java
/**
 * 全局返回对象
 */
@Data
@Accessors(chain = true)
public class Result<T> implements Serializable {

    @Serial
    private static final long serialVersionUID = 5679018624309023727L;

    /**
     * 正确返回码
     */
    public static final String SUCCESS_CODE = "0";

    /**
     * 返回码
     */
    private String code;

    /**
     * 返回消息
     */
    private String message;

    /**
     * 响应数据
     */
    private T data;

    /**
     * 请求ID
     */
    private String requestId;
    
    public boolean isSuccess() {
        return SUCCESS_CODE.equals(code);
    }
}
~~~

### 用户注册

使用布隆过滤器快速快速判断用户注册缓存

![image.png](https://cdn.nlark.com/yuque/0/2023/png/331027/1697719908916-ec7a2a18-acca-4ade-ba24-eb5996e97804.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_35%2Ctext_5pCc77yabmFnZW9mZmVyLmNvbQ%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp)

![image-20240408112013321](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240408112013321.png)

### 如何防止恶意请求毫秒级触发大量请求去一个未注册的用户名？

利用分布式锁来保证注册操作的正确性和并发安全性。

![image.png](https://cdn.nlark.com/yuque/0/2023/png/331027/1697729757482-51315028-a3f5-46c7-a872-70498e47ba4e.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_56%2Ctext_5pCc77yabmFnZW9mZmVyLmNvbQ%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp%2Fresize%2Cw_937%2Climit_0)

![image-20240408112210247](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240408112210247.png)

解决**并发注册重复用户名**：如果多个线程同时尝试注册相同的用户名，没有适当的同步措施，它们可能会同时通过 `hasUsername` 方法的检查，并且同时执行注册操作，导致重复的用户名被注册。通过使用分布式锁，只有一个线程能够获得注册锁，其他线程会被阻塞，直到锁被释放。这样可以确保在同一时刻只有一个线程能够执行注册操作，避免重复注册用户名。

### 分库分表

**为什么要分库分表**

- 数据量庞大。
- 查询性能缓慢，之前可能是 20ms，后续随着数据量的增长，查询时间呈指数增长。
- 数据库连接不够。

#### 分库分表的模式

垂直分库

<img src="https://cdn.nlark.com/yuque/0/2023/png/331027/1697876684861-58ccc1f2-1bcc-42da-a9f6-5eeae3bf6515.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_28%2Ctext_5pCc77yabmFnZW9mZmVyLmNvbQ%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp" alt="image.png" style="zoom:50%;" />

水平分库

<img src="https://cdn.nlark.com/yuque/0/2023/png/331027/1697876699843-6cb8f376-0484-4688-83ec-fbeb7f209b2a.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_23%2Ctext_5pCc77yabmFnZW9mZmVyLmNvbQ%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp" alt="image.png" style="zoom:50%;" />

垂直分表

<img src="https://cdn.nlark.com/yuque/0/2023/png/331027/1697876858482-0aca78dc-b208-4130-8fa0-c9a58b4d7a4c.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_28%2Ctext_5pCc77yabmFnZW9mZmVyLmNvbQ%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp" alt="image.png" style="zoom:50%;" />

水平分表

<img src="https://cdn.nlark.com/yuque/0/2023/png/331027/1697876929257-8704a59b-557c-4500-86d1-0f90d1154e8b.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_20%2Ctext_5pCc77yabmFnZW9mZmVyLmNvbQ%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp" alt="image.png" style="zoom: 50%;" />

## 数据库分库分表框架 ShardingSphere

#### 分片键

用于将数据库（表）水平拆分的数据库字段。 

**敏感数据加密存储**

<img src="https://cdn.nlark.com/yuque/0/2023/png/331027/1691732941183-41fe0c7c-93b8-4bcb-9f1a-362da5130e78.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_33%2Ctext_5pCc77yabmFnZW9mZmVyLmNvbQ%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp%2Fresize%2Cw_818%2Climit_0" alt="image.png" style="zoom:50%;" />

### 用户登录解决

先从数据库查询是否有用户的记录

![image-20240428151746570](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240428151746570.png)

1. 如果用户尚未登录过，则生成一个唯一的登录标识（使用 UUID），将用户信息存储到 Redis 中，并设置过期时间为 30 分钟。

   ![image-20240428151830480](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240428151830480.png)

2. 如果用户已经登录过，则从 Redis 中获取该用户的登录信息，并返回给客户端。

   ![image-20240428151816626](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240428151816626.png)

## 用户上下文配置

设置过滤器

![image-20240408151334220](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240408151334220.png)

过滤器中，获取登录的用户信息，并存入UserContext中。

![image-20240408151449321](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240408151449321.png)

![image-20240408151524762](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240408151524762.png)



## 短连接管理

### 分组模块

先查找用户名下拥有的分组数量，如果太多则无法插入

然后通过分片键（username）来进行插入

查询分组，先查询数量再查询具体

### 跳转原理

<img src="https://cdn.nlark.com/yuque/0/2023/png/331027/1697971222555-9805cb97-70f2-4637-b8d0-1484ff0c9432.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_53%2Ctext_5pCc77yabmFnZW9mZmVyLmNvbQ%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp" alt="image.png" style="zoom: 50%;" />

### 短链接生成算法

通过要跳转的网站加上uuid保证随机性

通过

~~~java
 int i = MurmurHash.hash32(str)
~~~

生成32位的hash值，哈希值转化为62进制的数

生成后插入数据库并写入redis缓存和布隆过滤器

![image.png](https://cdn.nlark.com/yuque/0/2023/png/331027/1697982327029-664df1e4-ff59-417f-8845-afe031a0d6e7.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_24%2Ctext_5pCc77yabmFnZW9mZmVyLmNvbQ%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp)

并且使用回滚事务防止生成失败仍然添加到缓存里面

![image-20240408162205672](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240408162205672.png)

### 短链接跳转

<img src="https://cdn.nlark.com/yuque/0/2023/png/331027/1698327418090-b715a793-0f5d-4862-ab07-637854e34f6a.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_38%2Ctext_5pCc77yabmFnZW9mZmVyLmNvbQ%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp" alt="image.png" style="zoom:67%;" />

先拼接访问的短链接网址获得完整短链接网址，然后去redis缓存查询是否存在，存在就记录访问次数和返回访问地址![image-20240408163117869](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240408163117869.png)

如果redis不存在就看布隆过滤器是否存在，用来防止缓存穿透。

使用布隆过滤器技术预先过滤掉不存在的请求，减少对数据库的查询压力。

![image-20240408163852851](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240408163852851.png)

判断是否为空值跳转路由表，可能会缓存为空

![image-20240408164156284](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240408164156284.png)

查找的时候使用分布式锁来预防缓存击穿的的问题，保证只有一个线程可以访问数据库，其他线程等待结果。

![image-20240408165137637](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240408165137637.png)

如果查询为空的话（布隆过滤器判断存在可能存在误判），就设置redis缓存为空，预防缓存击穿

![image-20240408165156436](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240408165156436.png)

```java
//查询真实信息
//根据full—shorturl和gid来查询信息，并且保证此短链接还可用，未被删除
 LambdaQueryWrapper<ShortLinkDO> queryWrapper = Wrappers.lambdaQuery(ShortLinkDO.class)
                    .eq(ShortLinkDO::getGid, shortLinkGotoDO.getGid())
                    .eq(ShortLinkDO::getFullShortUrl, fullShortUrl)
                    .eq(ShortLinkDO::getDelFlag, 0)
                    .eq(ShortLinkDO::getEnableStatus, 0);
            ShortLinkDO shortLinkDO = baseMapper.selectOne(queryWrapper);
            if (shortLinkDO == null || (shortLinkDO.getValidDate() != null && shortLinkDO.getValidDate().before(new Date()))) {
                stringRedisTemplate.opsForValue().set(String.format(GOTO_IS_NULL_SHORT_LINK_KEY, fullShortUrl), "-", 30, TimeUnit.MINUTES);
                ((HttpServletResponse) response).sendRedirect("/page/notfound");
                return;
            }
```

最后查找到更新缓存

![image-20240408165338183](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240408165338183.png)

### 短链接编辑

有代码漏洞，如果更改了gid，短链接记录可能就不存在了

因为分表时修改短链接分组(gid)要先删除（逻辑删除，还存在原表）再新增，可能导致新增的短链接路由到相同的表导致唯一索引冲突。新增的del_time和full_short_url组成唯一索引可以有效避免这种冲突。

新的唯一索引变成：full_short_url, del_time。

-------------------------------------------------------------------------------------------------------------------------

更新短链接信息时如果要修改gid，就获得redisson的写锁，确保没有其他正在访问我们的短链接，确保关键数据的一致性和完整性

![image-20240408183241132](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240408183241132.png)

### 短链接数据监控统计

uv实现

uv信息为一个uuid+fullshorturl，是独立访问呢标志

~~~java
  private ShortLinkStatsRecordDTO buildLinkStatsRecordAndSetUser(String fullShortUrl, ServletRequest request, ServletResponse response) {
       //线程安全性的
        AtomicBoolean uvFirstFlag = new AtomicBoolean();
        //获取访问请求的cookies
        Cookie[] cookies = ((HttpServletRequest) request).getCookies();
        AtomicReference<String> uv = new AtomicReference<>();
        //这个线程主要使设置uvcookies
        //通过使用线程，可以将这个生成 UUID 的过程异步化，
        // 即在一个单独的线程中执行，而不是在主线程中阻塞执行。
        // 这样，在用户的请求处理过程中，生成 UUID 的耗时操作不会影响到请求的响应速度，
        // 提高了系统的并发处理能力和响应速度。
        Runnable addResponseCookieTask = () -> {
            uv.set(UUID.fastUUID().toString());
            Cookie uvCookie = new Cookie("uv", uv.get());
            uvCookie.setMaxAge(60 * 60 * 24 * 30);
            uvCookie.setPath(StrUtil.sub(fullShortUrl, fullShortUrl.indexOf("/"), fullShortUrl.length()));
            //response添加返回cookie，后续再访问就会携带
            ((HttpServletResponse) response).addCookie(uvCookie);
            uvFirstFlag.set(Boolean.TRUE);
            //将uv信息添加到redis中
            stringRedisTemplate.opsForSet().add(SHORT_LINK_STATS_UV_KEY + fullShortUrl, uv.get());
        };
       //这段代码的作用是根据请求中是否存在 "uv" 的 Cookie，来执行不同的逻辑：
        // 如果存在 "uv" 的 Cookie，则更新 UV 相关的信息；
        // 如果不存在 "uv" 的 Cookie，则添加 "uv" Cookie 并记录 UV 相关信息。
        if (ArrayUtil.isNotEmpty(cookies)) {
            Arrays.stream(cookies)
                    .filter(each -> Objects.equals(each.getName(), "uv"))
                    .findFirst()
                    .map(Cookie::getValue)
                    //cookies是键值对形式，所以each也是uuid
                    .ifPresentOrElse(each -> {
                        uv.set(each);
                        //根据添加 UV 值到集合中的结果，是否能成功来判断
                        // 更新 uvFirstFlag 变量，表示是否为 UV 的首次访问。
                        Long uvAdded = stringRedisTemplate.opsForSet().add(SHORT_LINK_STATS_UV_KEY + fullShortUrl, each);
                        uvFirstFlag.set(uvAdded != null && uvAdded > 0L);
                    }, addResponseCookieTask);
        } else {
            addResponseCookieTask.run();
        }
~~~



![image.png](https://cdn.nlark.com/yuque/0/2023/png/331027/1699489408143-51dc185f-a3f9-46b1-8ae2-d5f8eab7f138.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_42%2Ctext_5pCc77yabmFnZW9mZmVyLmNvbQ%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp)

先从数据库获取监控的旧数据，

![image-20240408185433274](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240408185433274.png)

![image-20240408185606189](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240408185606189.png)

获取限定的时间范围

![image-20240408190417966](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240408190417966.png)

### 系统稳定性之流量控制

用户操作流量风控过滤器，限制用户的过度请求

![image-20240408152709572](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240408152709572.png)

![image-20240408152217030](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240408152217030.png)

利用lua脚本实现

![image-20240408152237762](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240408152237762.png)

每次访问执行递增，在一定时间内次数超过则返回执行失败结果

### rabbitmq的海量削峰

海量访问短链接，直接访问数据库，会导致数据库负载变高，甚至数据库宕机。为此，需要引入消息队列削峰

![image.png](https://cdn.nlark.com/yuque/0/2024/png/331027/1705208536338-d17adc09-d72f-40e4-8dd6-f5945bf07b70.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_50%2Ctext_5pCc77yabmFnZW9mZmVyLmNvbQ%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp)

确认消息消费的幂等性(无论执行多少次结果都是一样的)

先判断消息是否被消费过，确保消息幂等性。消费过就不进行处理。

如果消息未被消费过，则继续执行下面的逻辑。

在处理消息的过程中，可能会出现异常，例如处理订单时发生了某种异常。

在这种情况下，为了确保消息的完整性，需要将已处理的消息从标识列表中移除，避免重复处理。

### 布隆过滤器工作原理

布隆过滤器由「初始值都为 0 的位图数组」和「 N 个哈希函数」两部分组成。

布隆过滤器会通过 3 个操作完成标记：

- 第一步，使用 N 个哈希函数分别对数据做哈希计算，得到 N 个哈希值；
- 第二步，将第一步得到的 N 个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置。
- 第三步，将每个哈希值在位图数组的对应位置的值设置为 1；

**查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，数据库中一定就不存在这个数据**。

### 为什么需要t_link_goto

分表后的数据查询需要分片键，否则会有读扩散问题

短链接表使用的是 Gid 进行分表，用户通过浏览器访问短链接时，仅有短链接值，没有 Gid 的，所以我们就要建立个路由表，也就是 t_link_goto 进行缓存短链接和 Gid 的关系

但如果直接使用短链接来作为分片键会导致读扩散，因为我们是按gid来访问分组的短链接，gid不是分片键所以会造成读扩散

### 1. Redis 宕机，数据会丢失么？

Redis 提供了两套持久化机制，一个是 RDB，它会根据情况定期的 Fork 出一个子进程，生成当前数据库的全量快照；另一个是 AOF，它通过向 AOF 日志文件追加每一条执行过的指令实现

对于 RDB 快照**，假如我们在 RDB 快照生成后宕机，那么会丢失快照生成期间全部增量数据，如果在连快照都没成功生成，那么就会丢掉全部数据**。

而当我们仅开启了 AOF 时，**丢失数据的多少取决于我们设置的刷盘策略**：当设置为每条指令执行后都刷盘  `Always`，我们最多丢失一条指令；当设置为每秒刷一次盘的 `Eversec` 时，最多丢失一秒内的数据；当设置为非主动刷盘的 `No` 时，则可能丢失上次刷盘后到现在的全部数据

为了避免数据过多丢失，一般都会采用 AOF 方式。由于通过 AOF 恢复数据相对比较耗时，因此 Redis 在 4.0 以后允许通过 `aof‐use‐rdb‐preamble` 配置开启混合持久化

当 AOF 重写时（**Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件**），它将会先生成当前时间的 RDB 快照，然后将其写入新的 AOF 文件，接着再把增量数据追加到这个新 AOF 文件中。

如此一来，当 Redis 通过 AOF 文件恢复数据时，将会先加载 RDB，然后再重放后半部分的增量数据。这样就可以大幅度提高数据恢复的速度



### 为什么布隆过滤器远胜于分布式锁性能

如果是分布式锁来实现短链接的生成，先获取锁然后通过查询数据库判断短链接是否存在

布隆过滤器则直接判断

![image-20240507203020172](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240507203020172.png)

### 遇到的错误

4.30解决

