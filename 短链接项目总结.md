## 项目介绍

我这个项目主要是把一个原始长的URL通过特定的算法转变为短的URL，就只有5、6个字符的短URL，然后访问这个短链接就可以跳转到原始的链接。

然后对于创建的短链接我们可以去管理它，还可以去统计这个短链接的统计数据，比如点击量，点击的设备类型，点击ip的地址是什么等

**这个项目包含的模块**

有用户服务,包含用户的登录，注册，个人信息查看，还有短链接分组的增删改查功能，还有短链接的创建，修改，以及访问监控等功能。

**项目的亮点和难点**

- **缓存击穿&穿透**：缓存绕不过的坎，看咱们如何使用布隆过滤器、缓存空值以及分布式锁解决。

- **缓存一致性**：修改了短链接后，如何保障数据库的缓存和数据库保持一致性

- **海量存储**：可能需要存储大量的用户数据，包括数据库、缓存等，需要足够的存储和高效的存储管理方案

  采用了分库分表

  **海量并发**：可能会面对大量用户同时访问的情况，尤其高峰期，会对系统的性能和响应速度提出很高的要求

  采用了消息队列来记录客户的监控访问记录

## 后台用户管理

### 异常码设计

异常码分为3种

A 表示用户端

B 表示客户端

C 表示第三方服务

错误码设计，去实现这个接口

~~~java
public interface IErrorCode {
    //错误码
     
    String code();
	// 错误信息
    String message();
}
~~~

![image-20240428115457668](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240428115457668.png)

### 异常设计

<img src="C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240428115851366.png" alt="image-20240428115851366" style="zoom:67%;" />

客户端，服务端等都继承

~~~java
//抽象归约异常
public abstract class AbstractException extends RuntimeException {

    public final String errorCode;

    public final String errorMessage;

    public AbstractException(String message, Throwable throwable, IErrorCode errorCode) {
        super(message, throwable);
        this.errorCode = errorCode.code();
        this.errorMessage = Optional.ofNullable(StringUtils.hasLength(message) ? message : null).orElse(errorCode.message());
    }
}
~~~

### 全局异常拦截器

![image-20240428121036005](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240428121036005.png)

@RestControllerAdvice用于统一处理这些类中抛出的异常，并对返回的数据进行统一处理。

![image-20240428121353996](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240428121353996.png)

拦截指定的异常

~~~java
 @ExceptionHandler(value = {AbstractException.class})
    public Result abstractException(HttpServletRequest request, AbstractException ex) {
       //具体输出ex抛出的异常信息
        if (ex.getCause() != null) {
            log.error("[{}] {} [ex] {}", request.getMethod(), request.getRequestURL().toString(), ex.toString(), ex.getCause());
            return Results.failure(ex);
        }
        log.error("[{}] {} [ex] {}", request.getMethod(), request.getRequestURL().toString(), ex.toString());
        return Results.failure(ex);
    }
~~~

### 全局统一返回实体

~~~java
/**
 * 全局返回对象
 */
@Data
@Accessors(chain = true)
public class Result<T> implements Serializable {

    @Serial
    private static final long serialVersionUID = 5679018624309023727L;

    /**
     * 正确返回码
     */
    public static final String SUCCESS_CODE = "0";

    /**
     * 返回码
     */
    private String code;

    /**
     * 返回消息
     */
    private String message;

    /**
     * 响应数据
     */
    private T data;

    /**
     * 请求ID
     */
    private String requestId;
    
    public boolean isSuccess() {
        return SUCCESS_CODE.equals(code);
    }
}
~~~

### 用户注册

使用布隆过滤器快速快速判断用户注册缓存

![image.png](https://cdn.nlark.com/yuque/0/2023/png/331027/1697719908916-ec7a2a18-acca-4ade-ba24-eb5996e97804.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_35%2Ctext_5pCc77yabmFnZW9mZmVyLmNvbQ%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp)

![image-20240408112013321](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240408112013321.png)

### 如何防止恶意请求毫秒级触发大量请求去一个未注册的用户名？

利用分布式锁来保证注册操作的正确性和并发安全性。

![image.png](https://cdn.nlark.com/yuque/0/2023/png/331027/1697729757482-51315028-a3f5-46c7-a872-70498e47ba4e.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_56%2Ctext_5pCc77yabmFnZW9mZmVyLmNvbQ%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp%2Fresize%2Cw_937%2Climit_0)

![image-20240408112210247](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240408112210247.png)

解决**并发注册重复用户名**：如果多个线程同时尝试注册相同的用户名，没有适当的同步措施，它们可能会同时通过 `hasUsername` 方法的检查，并且同时执行注册操作，导致重复的用户名被注册。通过使用分布式锁，只有一个线程能够获得注册锁，其他线程会被阻塞，直到锁被释放。这样可以确保在同一时刻只有一个线程能够执行注册操作，避免重复注册用户名。

并且是使用trylock，得不到锁就立即返回

## 分库分表

**为什么要分库分表**

- 数据量庞大。
- 查询性能缓慢，之前可能是 20ms，后续随着数据量的增长，查询时间呈指数增长。
- 数据库连接不够。

#### 分库分表的模式

垂直分库

<img src="https://cdn.nlark.com/yuque/0/2023/png/331027/1697876684861-58ccc1f2-1bcc-42da-a9f6-5eeae3bf6515.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_28%2Ctext_5pCc77yabmFnZW9mZmVyLmNvbQ%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp" alt="image.png" style="zoom:50%;" />

水平分库

<img src="https://cdn.nlark.com/yuque/0/2023/png/331027/1697876699843-6cb8f376-0484-4688-83ec-fbeb7f209b2a.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_23%2Ctext_5pCc77yabmFnZW9mZmVyLmNvbQ%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp" alt="image.png" style="zoom:50%;" />

垂直分表

<img src="https://cdn.nlark.com/yuque/0/2023/png/331027/1697876858482-0aca78dc-b208-4130-8fa0-c9a58b4d7a4c.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_28%2Ctext_5pCc77yabmFnZW9mZmVyLmNvbQ%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp" alt="image.png" style="zoom:50%;" />

水平分表

<img src="https://cdn.nlark.com/yuque/0/2023/png/331027/1697876929257-8704a59b-557c-4500-86d1-0f90d1154e8b.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_20%2Ctext_5pCc77yabmFnZW9mZmVyLmNvbQ%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp" alt="image.png" style="zoom: 50%;" />

### 数据库分库分表框架 ShardingSphere

分片键

用于将数据库（表）水平拆分的数据库字段。 

**敏感数据加密存储**

<img src="https://cdn.nlark.com/yuque/0/2023/png/331027/1691732941183-41fe0c7c-93b8-4bcb-9f1a-362da5130e78.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_33%2Ctext_5pCc77yabmFnZW9mZmVyLmNvbQ%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp%2Fresize%2Cw_818%2Climit_0" alt="image.png" style="zoom:50%;" />

### 用户登录解决

先从数据库查询是否有用户的记录

![image-20240428151746570](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240428151746570.png)

1. 如果用户尚未登录过，则生成一个唯一的登录标识（使用 UUID），将用户信息存储到 Redis 中，并设置过期时间为 30 分钟。

   ![image-20240428151830480](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240428151830480.png)

2. 如果用户已经登录过，则从 Redis 中获取该用户的登录信息，并返回给客户端。

   ![image-20240428151816626](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240428151816626.png)

## 用户上下文配置

设置过滤器

![image-20240408151334220](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240408151334220.png)

过滤器中，获取登录的用户信息，并存入UserContext中。

![image-20240408151449321](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240408151449321.png)

![image-20240408151524762](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240408151524762.png)



## 短连接管理

**分组模块**

先查找用户名下拥有的分组数量，如果太多则无法插入

然后通过分片键（username）来进行插入

查询分组，先查询数量再查询具体

### 跳转原理

<img src="https://cdn.nlark.com/yuque/0/2023/png/331027/1697971222555-9805cb97-70f2-4637-b8d0-1484ff0c9432.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_53%2Ctext_5pCc77yabmFnZW9mZmVyLmNvbQ%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp" alt="image.png" style="zoom: 50%;" />

**短链接生成算法**

通过要跳转的网站加上uuid保证随机性

通过

~~~java
 int i = MurmurHash.hash32(str)
~~~

生成32位的hash值，哈希值转化为62进制的数

生成后插入数据库并写入redis缓存和布隆过滤器

<img src="https://cdn.nlark.com/yuque/0/2023/png/331027/1697982327029-664df1e4-ff59-417f-8845-afe031a0d6e7.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_24%2Ctext_5pCc77yabmFnZW9mZmVyLmNvbQ%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp" alt="image.png" style="zoom:33%;" />

并且使用回滚事务防止生成失败仍然添加到缓存里面

![image-20240408162205672](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240408162205672.png)

### 短链接跳转

<img src="https://cdn.nlark.com/yuque/0/2023/png/331027/1698327418090-b715a793-0f5d-4862-ab07-637854e34f6a.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_38%2Ctext_5pCc77yabmFnZW9mZmVyLmNvbQ%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp" alt="image.png" style="zoom:67%;" />

先拼接访问的短链接网址获得完整短链接网址，然后去redis缓存查询是否存在，存在就记录访问次数和返回访问地址![image-20240408163117869](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240408163117869.png)

如果redis不存在就看布隆过滤器是否存在，用来防止缓存穿透。

使用布隆过滤器技术预先过滤掉不存在的请求，减少对数据库的查询压力。

![image-20240408163852851](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240408163852851.png)

判断是否为空值跳转路由表，可能会缓存为空

![image-20240408164156284](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240408164156284.png)

查找的时候使用分布式锁来预防缓存击穿的的问题，保证只有一个线程可以访问数据库，其他线程等待结果。

![image-20240408165137637](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240408165137637.png)

如果查询为空的话（布隆过滤器判断存在可能存在误判），就设置redis缓存为空，预防缓存击穿

![image-20240408165156436](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240408165156436.png)

```java
//查询真实信息
//根据full—shorturl和gid来查询信息，并且保证此短链接还可用，未被删除
 LambdaQueryWrapper<ShortLinkDO> queryWrapper = Wrappers.lambdaQuery(ShortLinkDO.class)
                    .eq(ShortLinkDO::getGid, shortLinkGotoDO.getGid())
                    .eq(ShortLinkDO::getFullShortUrl, fullShortUrl)
                    .eq(ShortLinkDO::getDelFlag, 0)
                    .eq(ShortLinkDO::getEnableStatus, 0);
            ShortLinkDO shortLinkDO = baseMapper.selectOne(queryWrapper);
            if (shortLinkDO == null || (shortLinkDO.getValidDate() != null && shortLinkDO.getValidDate().before(new Date()))) {
                stringRedisTemplate.opsForValue().set(String.format(GOTO_IS_NULL_SHORT_LINK_KEY, fullShortUrl), "-", 30, TimeUnit.MINUTES);
                ((HttpServletResponse) response).sendRedirect("/page/notfound");
                return;
            }
```

最后查找到更新缓存

![image-20240408165338183](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240408165338183.png)

### 短链接编辑

有代码漏洞，如果更改了gid，短链接记录可能就不存在了

因为分表时修改短链接分组(gid)要先删除（逻辑删除，还存在原表）再新增，可能导致新增的短链接路由到相同的表导致唯一索引冲突。新增的del_time和full_short_url组成唯一索引可以有效避免这种冲突。

新的唯一索引变成：full_short_url, del_time。

-------------------------------------------------------------------------------------------------------------------------

更新短链接信息时如果要修改gid，就获得redisson的写锁，确保没有其他正在访问我们的短链接，确保关键数据的一致性和完整性

![image-20240408183241132](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240408183241132.png)

### 短链接数据监控统计

uv实现

uv信息为一个uuid+fullshorturl，是独立访问呢标志

~~~java
  private ShortLinkStatsRecordDTO buildLinkStatsRecordAndSetUser(String fullShortUrl, ServletRequest request, ServletResponse response) {
       //线程安全性的
        AtomicBoolean uvFirstFlag = new AtomicBoolean();
        //获取访问请求的cookies
        Cookie[] cookies = ((HttpServletRequest) request).getCookies();
        AtomicReference<String> uv = new AtomicReference<>();
        //这个线程主要使设置uvcookies
        //通过使用线程，可以将这个生成 UUID 的过程异步化，
        // 即在一个单独的线程中执行，而不是在主线程中阻塞执行。
        // 这样，在用户的请求处理过程中，生成 UUID 的耗时操作不会影响到请求的响应速度，
        // 提高了系统的并发处理能力和响应速度。
        Runnable addResponseCookieTask = () -> {
            uv.set(UUID.fastUUID().toString());
            Cookie uvCookie = new Cookie("uv", uv.get());
            uvCookie.setMaxAge(60 * 60 * 24 * 30);
            uvCookie.setPath(StrUtil.sub(fullShortUrl, fullShortUrl.indexOf("/"), fullShortUrl.length()));
            //response添加返回cookie，后续再访问就会携带
            ((HttpServletResponse) response).addCookie(uvCookie);
            uvFirstFlag.set(Boolean.TRUE);
            //将uv信息添加到redis中
            stringRedisTemplate.opsForSet().add(SHORT_LINK_STATS_UV_KEY + fullShortUrl, uv.get());
        };
       //这段代码的作用是根据请求中是否存在 "uv" 的 Cookie，来执行不同的逻辑：
        // 如果存在 "uv" 的 Cookie，则更新 UV 相关的信息；
        // 如果不存在 "uv" 的 Cookie，则添加 "uv" Cookie 并记录 UV 相关信息。
        if (ArrayUtil.isNotEmpty(cookies)) {
            Arrays.stream(cookies)
                    .filter(each -> Objects.equals(each.getName(), "uv"))
                    .findFirst()
                    .map(Cookie::getValue)
                    //cookies是键值对形式，所以each也是uuid
                    .ifPresentOrElse(each -> {
                        uv.set(each);
                        //根据添加 UV 值到集合中的结果，是否能成功来判断
                        // 更新 uvFirstFlag 变量，表示是否为 UV 的首次访问。
                        Long uvAdded = stringRedisTemplate.opsForSet().add(SHORT_LINK_STATS_UV_KEY + fullShortUrl, each);
                        uvFirstFlag.set(uvAdded != null && uvAdded > 0L);
                    }, addResponseCookieTask);
        } else {
            addResponseCookieTask.run();
        }
~~~



![image.png](https://cdn.nlark.com/yuque/0/2023/png/331027/1699489408143-51dc185f-a3f9-46b1-8ae2-d5f8eab7f138.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_42%2Ctext_5pCc77yabmFnZW9mZmVyLmNvbQ%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp)

先从数据库获取监控的旧数据，

![image-20240408185433274](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240408185433274.png)

![image-20240408185606189](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240408185606189.png)

获取限定的时间范围

![image-20240408190417966](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240408190417966.png)

### 系统稳定性之流量控制

用户操作流量风控过滤器，限制用户的过度请求

![image-20240408152709572](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240408152709572.png)

![image-20240408152217030](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240408152217030.png)

利用lua脚本实现

![image-20240408152237762](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240408152237762.png)

每次访问执行递增，在一定时间内次数超过则返回执行失败结果

### RocketMq的海量削峰

海量访问短链接，直接访问数据库，会导致数据库负载变高，甚至数据库宕机。为此，需要引入消息队列削峰

<img src="https://cdn.nlark.com/yuque/0/2024/png/331027/1705208536338-d17adc09-d72f-40e4-8dd6-f5945bf07b70.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_50%2Ctext_5pCc77yabmFnZW9mZmVyLmNvbQ%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp" alt="image.png" style="zoom: 33%;" />

消费组的消息队列，只会安排固定安排几个线程去拉取消息消费，在消息队列中不需要安排延迟队列，因为阻塞就阻塞那几个固定的线程而不会造成大量线程阻塞造成的OOM



确认消息消费的幂等性

消息的幂等性其实就是保证同一条消息不会重复或者重复消费了也不会对系统数据造成异常

先判断消息是否被处理过，看在redis中是否有这个全局ID的缓存，如果有则是处理过

![image-20240520150019448](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240520150019448.png)

如果完成了则设置redis中缓存对应的值为1

如果消息未被消费过，则继续执行下面的逻辑。



在处理消息的过程中，可能会出现异常，例如处理订单时发生了某种异常。

在这种情况下，为了确保消息的完整性，需要将已处理的消息从标识列表中移除，避免重复处理。

### 布隆过滤器工作原理

布隆过滤器由「初始值都为 0 的位图数组」和「 N 个哈希函数」两部分组成。

布隆过滤器会通过 3 个操作完成标记：

- 第一步，使用 N 个哈希函数分别对数据做哈希计算，得到 N 个哈希值；
- 第二步，将第一步得到的 N 个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置。
- 第三步，将每个哈希值在位图数组的对应位置的值设置为 1；

**查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，数据库中一定就不存在这个数据**。

### 为什么需要t_link_goto

分表后的数据查询需要分片键，否则会有读扩散问题

短链接表使用的是 Gid 进行分表，用户通过浏览器访问短链接时，仅有短链接值，没有 Gid 的，所以我们就要建立个路由表，也就是 t_link_goto 进行缓存短链接和 Gid 的关系

但如果直接使用短链接来作为分片键会导致读扩散，因为我们是按gid来访问分组的短链接，gid不是分片键所以会造成读扩散

### 1. Redis 宕机，数据会丢失么？

Redis 提供了两套持久化机制，一个是 RDB，它会根据情况定期的 Fork 出一个子进程，生成当前数据库的全量快照；另一个是 AOF，它通过向 AOF 日志文件追加每一条执行过的指令实现

对于 RDB 快照**，假如我们在 RDB 快照生成后宕机，那么会丢失快照生成期间全部增量数据，如果在连快照都没成功生成，那么就会丢掉全部数据**。

而当我们仅开启了 AOF 时，**丢失数据的多少取决于我们设置的刷盘策略**：当设置为每条指令执行后都刷盘  `Always`，我们最多丢失一条指令；当设置为每秒刷一次盘的 `Eversec` 时，最多丢失一秒内的数据；当设置为非主动刷盘的 `No` 时，则可能丢失上次刷盘后到现在的全部数据

为了避免数据过多丢失，一般都会采用 AOF 方式。由于通过 AOF 恢复数据相对比较耗时，因此 Redis 在 4.0 以后允许通过 `aof‐use‐rdb‐preamble` 配置开启混合持久化

当 AOF 重写时（**Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件**），它将会先生成当前时间的 RDB 快照，然后将其写入新的 AOF 文件，接着再把增量数据追加到这个新 AOF 文件中。

如此一来，当 Redis 通过 AOF 文件恢复数据时，将会先加载 RDB，然后再重放后半部分的增量数据。这样就可以大幅度提高数据恢复的速度



### 为什么布隆过滤器远胜于分布式锁性能

如果是分布式锁来实现短链接的生成，先获取锁然后通过查询数据库判断短链接是否存在

布隆过滤器则直接判断，那么布隆过滤器的性能就比分布式锁好

性能压测

4核16G

大概是分布式锁性能的6倍左右

![image-20240508143015718](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240508143015718.png)

分布式锁

![image-20240508143033977](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240508143033977.png)

### 短链接跳转并发量

40个线程，100次循环

都是访问缓存跳转所以比较快

![image-20240508144632959](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240508144632959.png)

### 缓存预热

就是将刚生成的短链接存入到缓存中。

因为有可能发生刚创建的短链接被大量并发请求访问，缓存没有的话就会大量请求访问数据库

### 封装缓存不存在读取功能，通过双重判定锁优化更新或失效场景下大量查询数据库问题

不存在读取功能就是

先查询布隆过滤器是否有，然后查询缓存，再查询数据库，并且查询数据库的时候加上分布式锁来限制访问数据库的请求，如果为空，那么设置缓存为空并设置过期时间

双重判定锁是指获取锁之前和之后分别进行一次检查，以确保只有第一个线程可以创建实例，后续的线程都会复用该实例。

这里就是数据库存在，但有大量的短链接在redis中失效，然后有大量请求到达数据库，这时就用到分布式锁，然后用lock阻塞，只有一个线程获取到了锁，然后线程完成数据库访问更新缓存，接下来其他线程获取锁就能获取到缓存中的原始链接，而不是去数据库查询

#### 利用 Redisson 分布式读写锁功能，实现了短链接在大量访问场景下的数据修改功能。

就是利用读写锁保证确保数据修改的安全和一致性，因为如果在进行短链接的读取时，有操作修改统计数据就会导致数据的不一致，而我们获取写锁可以保证其他的读锁线程阻塞

为什么用读写锁而不是用分布式锁？

因为分布式锁是串行化，吞吐量较低。读写锁中有两个锁种类，读锁和读锁之间是可以共享的，写写和读写才是互斥的



在 `ShortLinkServiceImpl#updateShortLink` 方法种有这一段逻辑，发现数据变更了，先更新数据库，然后再删除缓存

trylock是尝试获取锁获取不到就返回，而lock是会阻塞等待获取锁的



### 如何实现布隆过滤器删除

加一层验证，在访问布隆过滤器的时候加一层set来验证

## 短链接上线部署

首先先下载jdk17，部署到java文件夹，配置java环境

安装nginx，然后项目打包，mvn clean instal

Maven 执行 clean install 逻辑，然后mvn run build 将 SpringBoot 可执行 Jar 生成。

前端 npm run build 生成dist文件夹

然后安装docker，在docker里面安装mysql，redis，nacos等

把数据库的数据和库通过mysql工具连接网络并导入到服务器

有个问题mysql的时间与本地时间不一致，是因为docker配置原因

然后安装配置redis和nacos

