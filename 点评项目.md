这个项目主要时基于redis的使用来解决实际中可能会出现的缓存击穿，缓存穿透的问题，并学习redis分布式锁和消息队列和redis的一些数据结构使用



项目中遇到的一些困难

配置拦截器的时候忘记添加@configuration，导致拦截器失效 

### 使用 Redis 解决了在集群模式下的 Session共享问题,使用拦截器实现用户的登录校验和权限刷新

HTTP协议是无状态的，在开发中我们可以将用户的信息存储在服务器的session中。但是如果在分布式环境下，会产生session共享问题，即session的数据在服务1中存在，但是在服务2中不存在。

权限刷新就是通过一个拦截器拦截所有请求，符合条件就刷新token权限

### 基于Cache Aside模式解决数据库与缓存的一致性问题 

Cache Aside：缓存模式，缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案

更新缓存为删除策略再更新

### 使用 Redis 对高频访问的信息进行缓存，降低了数据库查询的压力,

缓存预热

###  解决了缓存穿透、

使用布隆过滤器，或者缓存null值

### 雪崩：同一时段大量的缓存key同时失效或者Redis服务宕机

给不同的Key的TTL添加随机值，利用Redis集群提高服务的可用性（主从Redis集群，一个Redis失效后，Redis哨兵检测到就替换主从）

### 击穿问题：热点key失效问题

互斥锁:利用分布式锁

逻辑过期：当用户开始查询redis时，判断是否命中，如果没有命中则直接返回空数据，不查询数据库，而一旦命中后，将value取出，判断value中的过期时间是否满足，如果没有过期，则直接返回redis中的数据，如果过期，则在开启独立线程后直接返回之前的数据，独立线程去重构数据，重构完成后释放互斥锁。

### 使用 Redis + Lua脚 本实现对用户秒杀资格的预检，同时用乐观锁解决秒杀产生的超卖问

全局唯一id，使用时间戳

 乐观锁：会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过，当然乐观锁还有一些变种的处理方式比如cas

秒杀资格为set集合是否有数据

### 使用Redis分布式锁解决了在集群模式下一人一单的线程安全问题

不同服务器相同锁不互斥就是锁失效了

* 利用set nx ex获取锁，并设置过期时间，保存线程标示
* 释放锁时先判断线程标示是否与自己一致，一致则删除锁
  * 特性：
    * 利用set nx满足互斥性
    * 利用set ex保证故障时锁依然能释放，避免死锁，提高安全性
    * 利用Redis集群保证高可用和高并发特性

事务想要生效需要利用代理来实现

使用分布式锁的时候，获取锁时加入自身信息，避免释放锁的时候删除别人的锁

最好使用lua脚本进行释放锁操作，确保命令的原子性

5. ### 基于stream结构作为消息队列,实现异步秒杀下单 

   * 创建一个Stream类型的消息队列，名为stream.orders
   * 修改之前的秒杀下单Lua脚本，在认定有抢购资格后，直接向stream.orders中添加消息，内容包含voucherId、userId、orderId
   * 项目启动时，开启一个线程任务，尝试获取stream.orders中的消息，完成下单\

6. ### 使用Redis的 ZSet 数据结构实现了点赞排行榜功能,使用Set 集合实现关注、共同关注功能

​	求set集合中的交集

### Redis和数据库怎么保存一致

对于读数据，我会选择旁路缓存策略，如果 cache 不命中，会从 db 加载数据到 cache。对于写数据，我会选择更新 db 后，再删除缓存。



### 针对缓存删除失败情况

针对删除缓存异常的情况，我还会对 key 设置过期时间兜底，只要过期时间一到，过期的 key 就会被删除了。

还可以用消息队列来删除，

- 如果应用**删除缓存失败**，可以从消息队列中重新读取数据，然后再次删除缓存，这个就是**重试机制**。当然，如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了。
- 如果**删除缓存成功**，就要把数据从消息队列中移除，避免重复操作，否则就继续重试。