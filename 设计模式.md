### 工厂模式

提供了一种有效安全创建对象的 方式，将创建实例的过程封装在工厂方法中，不暴露对象创建的具体细节

![](https://github.com/jimmy-bond/Image/blob/main/image-20240520160056326.png?raw=true)

### 抽象工厂

抽象工厂模式（Abstract Factory Pattern）在工厂模式上添加 了一个创建不同工厂的抽象接口（抽象类或接口实现），该接口可叫 作超级工厂。在使用过程中，我们首先通过抽象接口创建出不同的工 厂对象，然后根据不同的工厂对象创建不同的对象

抽象工厂可以说是多个不同工厂的接口

多维物品的分类

![](https://github.com/jimmy-bond/Image/blob/main/image-20240520160614116.png?raw=true)

![image-20240520162513619](https://github.com/jimmy-bond/Image/blob/main/image-20240520162513619.png?raw=true)

### 单例模式

确保一个类在应用程序或系统中只有一个实例，并提供一个全局访问点

~~~java
public class Singleton {
    private static Singleton instance;
    
    private Singleton() {
        // 私有构造方法
    }
    
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
~~~

单例模式首先通过 将类的实例化方法私有化来防止程序通过其他方式创建该类的实例， 然后通过提供一个全局唯一并且公开获取该类实例的方法帮助用户获取类的实 例，用户只需也只能通过调用该方法获取类的实例。

**懒汉模式（线程安全）**

加锁确保安全

![image-20240520162933288](https://github.com/jimmy-bond/Image/blob/main/image-20240520162933288.png?raw=true)

**饿汉模式**

![image-20240520163128337](https://github.com/jimmy-bond/Image/blob/main/image-20240520163128337.png?raw=true)

### 类的耦合

表示的是类和类之间的依赖关系，耦合度越高，一个类受影响修改后可能会间接的影响耦合度高的类

## 模板模式

在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。

~~~java
public abstract class penguin {
    public void eating() {
        System.out.println("吃饭");
    }
    public void sleeping() {
        System.out.println("睡觉");
    }
    public abstract void beating();
    public void everyDay() {
        this.eating();
        this.sleeping();
        this.beating();
    }
}
//要实现它们的方法就extend这个类，并重写抽象方法即可
~~~

uml图

![image-20240611100611818](https://github.com/jimmy-bond/Image/blob/main/image-20240611100611818.png?raw=true)

## 策略模式

> 在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。

~~~java
public class behaviorContext {
    private penguin _penguin;

    public behaviorContext(penguin newPenguin) {
        _penguin = newPenguin;
    }
    public void setPenguin(penguin newPenguin) {
        _penguin = newPenguin;
    }
    public void everyDay() {
        _penguin.eating();
        _penguin.sleeping();
        _penguin.beating();
    }
}
~~~

调用方式

~~~java
public class test {
    public static void main(String[] args) {
        behaviorContext behavior = new behaviorContext(new littlePenguin());
        behavior.everyDay();

        behavior.setPenguin(new middlePenguin());
        behavior.everyDay();

        behavior.setPenguin(new bigPenguin());
        behavior.everyDay();
    }
}
~~~

可以通过给behaviorContext传递不同的对象，然后来约定everyDay()的调用方式

![image-20240611101134144](https://github.com/jimmy-bond/Image/blob/main/image-20240611101134144.png?raw=true)

- **创建型**模式提供创建对象的机制，增加已有代码的灵活性和 可复用性。 
- **结构型**模式介绍如何将对象和类组装成较大的结构，并同时 保持结构的灵活和高效。 
- **行为**模式负责对象间的高效沟通和职责委派。

### 优秀的设计特征

- 代码复用
- 软件扩展性

### 设计原则

#### 封装变化的内容：

这原则的主要目的是将变更造成的影响最小化。

#### 方法层面封装：

例如getvalue()方法中可以抽离出计算calcvalue()的方法，这样以后修改也可以减少代码的改动

#### 类层面封装：

将内容抽取到一个新类中会让程序更加清晰和简洁。

<img src="https://github.com/jimmy-bond/Image/blob/main/image-20240611114307398.png?raw=true" style="zoom:50%;" />

<img src="C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240611114323507.png" alt="image-20240611114323507" style="zoom:50%;" />

#### 面向接口进行开发， 而不是面向实现 

#### 组合优于继承

继承缺点：

- 需要实现超类的所有抽象接口，即便有些接口没有用处
- 在重写方法时，你需要确保新行为与其基类中的版本兼容。因为子类的所有对象都可能被传递给以超类 对象为参数的任何代码
- 子类与超类紧密耦合。超类中的任何修改都可能会破坏子类 的功能。

## 开发中的solid原则

-  单一职责原则 Single Responsibility Principle

  ​	尽量让每个类只负责一个功能，并且功能封装在类中。类的十几个清晰方法就可以代替200行的代码设计

  <img src="https://github.com/jimmy-bond/Image/blob/main/image-20240612125656657.png?raw=true" style="zoom:50%;" />

  <img src="https://github.com/jimmy-bond/Image/blob/main/image-20240612125703440.png?raw=true" style="zoom:50%;" />

- 开闭原则 Open/closed Principle

  对于扩展，类应该是“开放”的；对于修改，类则应 是“封闭”的。

  理念是新功能开发时保持已有代码的不变

- 里氏替换原则 Liskov Substitution Principle 

  当你扩展一个类时， 记住你应该要能在不修改客户端 代码的情况下将子类的对象作为父类对象进行传递。

- 接口隔离原则 Interface Segregation Principle

  尽量缩小接口的范围，使得客户端的类不必实现其不需要的 行为。

- 依赖倒置原则 Dependency Inversion Principle

  高层次的类不应该依赖于低层次的类。 两者都应该依 赖于抽象接口。抽象接口不应依赖于具体实现。具体 实现应该依赖于抽象接口。

## 设计模式目录

**创建型模式：提供创建对象的机制，提高代码的灵活性和可复用性**

### 工厂方法

==[工厂方法](https://refactoringguru.cn/design-patterns/factory-method)是一种依赖于继承的设计模式。 如果将它设置为 `static` ， 你就不能在子类中对其进行扩展， 这就破坏了该模式的目的。==

产品需要实现某一个通用接口，

然后创建一个基础的工厂创建者，基础的工厂创建者（抽象类）提供一个抽象产品创建方法，具体的工厂创建者继承基础工厂，并实现抽象方法返回实际产品。那么我们就可以通过基础的工厂创建者的方法接口输入不同参数来获得不同的产品。

==在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。==

并且产品应该具有共同的基类或者接口，这样传递一个参数后就可以获得对应的服务，而不需要具体额外的参数。

<img src="https://github.com/jimmy-bond/Image/blob/main/image-20240612132325370.png?raw=true" style="zoom:50%;" />

工厂方法结构

![image-20240612133429720](https://github.com/jimmy-bond/Image/blob/main/image-20240612133429720.png?raw=true)

- （产品）Product：对通用接口进行声明
- 具体产品（Concrete Products）是产品接口的不同实现。
- 基础创建者（Creator）类声明返回产品对象的工厂方法。
- 具体创建者（Concrete Creators） 将会重写基础工厂方法， 使其返回不同类型的产品。

适用场景

如果你希望复用现有对象来节省系统资源，而不是每次都重 新创建对象，可使用工厂方法。

优缺点

- 单一职责原则：利于代码维护
- 避免创建者和具体产品之间的紧密耦合。

### 抽象工厂模式

==**抽象工厂** 》 是一种创建型设计模式， 它能创建一系列相关或相互依赖的对象， 而无需指定其具体类。==

产品同样实现一个通用接口，不过产品种类更多

不过基础的创建者由抽象类转换成了抽象接口，具体工厂实现这个抽象接口，来返回具体产品

![image-20240613100031431](https://github.com/jimmy-bond/Image/blob/main/image-20240613100031431.png?raw=true)

和工厂模式的区别在于

将创建具体的类工厂都继承一个抽象工厂的接口，用户只调用这个抽象接口方法就可以获取具体类

#### 适用场景

需要生产不同系列的相关产品

### 单例模式

你能够保证一个类只有一个实例，并提供一个访问该实例的全局节点。

普通构造函数难以实现，因为普通构造函数会返回一个新对象

#### 实现的两个相同步骤

构造方法的私有化

静态构建方法作为构造函数，该函数会调用私有构造函数来创建对象，并将其保存在一个静态成员变 量中。

![image-20240613103937731](https://github.com/jimmy-bond/Image/blob/main/image-20240613103937731.png?raw=true)

#### 适用场景

严格控制全局变量

### 生成器模式

你能够分步骤创建复杂对象。该模式允许你使用相同的创建代码生成不同类型和形式的对象

生成器模式建议将对象构造代码从产品类中抽取出来，并将 其放在一个名为生成器的独立对象中

![image-20240614134757776](../../../AppData/Roaming/Typora/typora-user-images/image-20240614134757776.png)

### 原型模式

使你能够复制已有对象，而又无需 使代码依赖它们所属的类

原型模式将克隆过程委派给被克隆的实际对象。模式为所有 支持克隆的对象声明了一个通用接口

#### 基本结构实现

<img src="../../../AppData/Roaming/Typora/typora-user-images/image-20240619141439532.png" alt="image-20240619141439532" style="zoom:67%;" />

1. 原型接口提供一个克隆方法
2. 具体类实现克隆方法
3. 客户端可以复制实现了原型接口的任何对象

#### 代码示例

抽象类，定义克隆方法

~~~java
public abstract class Shape {
    public int x;
    public int y;
    public String color;
    public Shape() {
    }

    public Shape(Shape target) {
        if (target != null) {
            this.x = target.x;
            this.y = target.y;
            this.color = target.color;
        }
    }
    public abstract Shape clone();

}
~~~

具体实现类实现抽象的克隆方法

~~~java
public class Circle extends Shape {
    public int radius;

    public Circle() {
    }

    public Circle(Circle target) {
        super(target);
        if (target != null) {
            this.radius = target.radius;
        }
    }

    @Override
    public Shape clone() {
        return new Circle(this);
    }
}
~~~

当我们调用某个clone方法时即可获取对象，

还可以创建一个克隆工厂，给出对应参数或者对象就可以获取其克隆对象

~~~java
Circle circle = new Circle();
Circle anotherCircle = (Circle) circle.clone();
//使用map数据结构来当存储的容器，
 public class BundledShapeCache {

    private Map<String, Shape> cache = new HashMap<>();

    public Shape put(String key, Shape shape) {
        cache.put(key, shape);
        return shape;
    }
//获取对象的ke'lon
    public Shape get(String key) {
        return cache.get(key).clone();
    }
}
~~~

#### 适用场景

当我们想克隆对象但又想独立于对象所属的具体类，使用原型模式



### 观察者模式

观察者是一种行为设计模式， 允许你定义一种订阅机制，可在对象事件发生时通知多个“观察”该对象的其他对象。

所有订阅者都必须实现同样的接口，发布者仅通过该 接口与订阅者交互。接口中必须声明通知方法及其参数，这样发布者在发出通知时还能传递一些上下文数据。

#### 工作原理

- 主题对象维护一个观察者列表，当状态发生变化时，它会遍历这个列表并通知所有观察者。
- 观察者实现一个接口或抽象类，该接口或抽象类定义了通知方法，供主题调用。
- 当主题发生变化时，publisher调用接口方法来实现通知

![image-20240614141252821](../../../AppData/Roaming/Typora/typora-user-images/image-20240614141252821.png)

#### 实现步骤

定义声明一个通用的接口，用来实现通知更新

~~~java
public interface Listener {
    public void update(String type);
}
~~~

观察者就需要实现这个接口

~~~java
public class PhoneListener implements Listener{
    @Override
    public void update(String type) {
        System.out.println("phoneCall");
    }
}
~~~

有一个发布者，它里面有一个成员变量来存储订阅者们

~~~java
public class EventManager {
    Map<String, List<Listener>> listeners = new HashMap<>();
    //当主题发生变化的时候就通过notify来
      public void notify(String eventType) {
        if(eventType.equals("phone")){
            List<Listener> list = listeners.get("phone");
            for (Listener listener : list) {
                listener.update("..");
            }
        }
        else{
            return;
        }
    }
    }
~~~

### 策略模式

是一种行为设计模式， 它能让你定义一系列算法， 并将每种算法分别放入独立的类中，以使算法的对　 象能够相互替换。

将一组行为转换为对象，使其在原始上下文对象内部能够相互替换

策略模式建议找出负责用许多不同方式完成特定任务的类， 然后将其中的算法抽取到一组被称为策略的独立类中。

<img src="../../../AppData/Roaming/Typora/typora-user-images/image-20240704111604758.png" alt="image-20240704111604758" style="zoom:50%;" />

1. 上下文（Context）维护指向具体策略的引用，且仅通过策略 接口与该对象进行交流。
2.   策略（Strategy）接口是所有具体策略的通用接口，它声明 了一个上下文用于执行策略的方法。
3.  具体策略（Concrete Strategies）实现了上下文所用算法的各 种不同变体。
4. 当上下文需要运行算法时，它会在其已连接的策略对象上调 用执行方法。上下文不清楚其所涉及的策略类型与算法的执 行方式。
5.  客户端（Client）会创建一个特定策略对象并将其传递给上下文。上下文则会提供一个设置器以便客户端在运行时替换 相关联的策略。

在不扩展类的情况下向用户提供改变其行为的方式
