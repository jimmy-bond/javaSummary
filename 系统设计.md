## 认证授权

- **认证 (Authentication)：** 你是谁。
- **授权 (Authorization)：** 你有权限干什么

### RBAC 模型

系统权限控制最常采用的访问控制模型就是 **RBAC 模型** 。

RBAC 即基于角色的权限访问控制（Role-Based Access Control）。这是一种通过角色关联权限，角色同时又关联用户的授权的方式。

![RBAC 权限模型示意图](https://oss.javaguide.cn/github/javaguide/system-design/security/design-of-authority-system/rbac.png)

数据库的表设计如下

![img](https://oss.javaguide.cn/2020-11/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1-%E6%9D%83%E9%99%90.png)

### Cookie

`Cookie` 和 `Session` 都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。

**`Cookie` 存放在客户端，一般用来保存用户信息**。

#### cokkie应用案例

1. 我们在 `Cookie` 中保存已经登录过的用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了。除此之外，`Cookie` 还能保存用户首选项，主题和其他设置信息。
2. 使用 `Cookie` 保存 **SessionId 或者 Token** ，向后端发送请求的时候带上 `Cookie`，这样后端就能取到 `Session` 或者 `Token` 了。这样就能记录用户当前的状态了，**因为 HTTP 协议是无状态的。**
3. `Cookie` 还可以用来记录和分析用户行为。举个简单的例子你在网上购物的时候，因为 HTTP 协议是没有状态的，如果服务器想要获取你在某个页面的停留状态或者看了哪些商品，一种常用的实现方式就是将这些信息存放在 `Cookie`

#### Cookie和**`Session`** 区别

**`Session` 的主要作用就是通过服务端记录用户的状态。**，典型场景就是服务器为用户保存购物车

服务器登录验证通过后，服务器为用户创建一个 `Session`，并将 `Session` 信息存储起来。

### 如何使用 Session-Cookie 方案进行身份验证？

`SessionID` 一般会选择存放在 Redis 

1. 用户成功登陆系统，然后返回给客户端具有 `SessionID` 的 `Cookie` 。
2. 当用户向后端发起请求的时候会把 `SessionID` 带上，这样后端就知道你的身份状态了。

### 如果没有 Cookie 的话 Session 还能用吗？

一般是通过 `Cookie` 来保存 `SessionID` ，假如你使用了 `Cookie` 保存 `SessionID` 的方案的话， 如果客户端禁用了 `Cookie`，那么 `Session` 就无法正常工作。

但可以把id放在url里面，但用户体验降低

### 为什么 Cookie 无法防止 CSRF 攻击，而 Token 可以？

**CSRF(Cross Site Request Forgery)** 一般被翻译为 **跨站请求伪造** 

`Session` 认证中 `Cookie` 中的 `SessionId` 是由浏览器发送到服务端的，借助这个特性，攻击者就可以通过让用户误点攻击链接，达到攻击效果。

## JWT

JWT （JSON Web Token）

JWT 自身包含了身份验证所需要的所有信息，因此，我们的服务器不需要存储 Session 信息。这显然增加了系统的可用性和伸缩性，大大减轻了服务端的压力。

jwt是存储在本地的，并且不会每个请求都附加上jwt，需要JavaScript的配合，也就是前端页面

组成部分

JWT 本质上就是一组字串，通过（`.`）切分成三个为 Base64 编码的部分：

- **Header** : 描述 JWT 的元数据，定义了生成签名的算法以及 `Token` 的类型。

  ~~~json
  {
    "alg": "HS256",//签名算法
    "typ": "JWT"//令牌类型
  }
  ~~~

- **Payload** : 用来存放实际需要传递的数据

  包含了 Claims(声明，包含 JWT 的相关信息)。

  Claims 分为三种类型：

  - **Registered Claims（注册声明）**：预定义的一些声明，建议使用，但不是强制性的。
  - **Public Claims（公有声明）**：JWT 签发方可以自定义的声明，但是为了避免冲突，应该在 [IANA JSON Web Token Registryopen in new window](https://www.iana.org/assignments/jwt/jwt.xhtml) 中定义它们。
  - **Private Claims（私有声明）**：JWT 签发方因为项目需要而自定义的声明，更符合实际项目场景使用。

  **下面是一些常见的注册声明：**

  - `iss`（issuer）：JWT 签发方。
  - `iat`（issued at time）：JWT 签发时间。
  - `sub`（subject）：JWT 主题。
  - `aud`（audience）：JWT 接收方。
  - `exp`（expiration time）：JWT 的过期时间。
  - `nbf`（not before time）：JWT 生效时间，早于该定义的时间的 JWT 不能被接受处理。
  - `jti`（JWT ID）：JWT 唯一标识。

  示例：

  

  ```json
  {
    "uid": "ff1212f5-d8d1-4496-bf41-d2dda73de19a",
    "sub": "1234567890",
    "name": "John Doe",
    "exp": 15323232,
    "iat": 1516239022,
    "scope": ["admin", "user"]
  }
  ```

  Payload 部分默认是不加密的，**一定不要将隐私信息存放在 Payload 当中！！！**

- **Signature（签名）**：服务器通过 Payload、Header 和一个密钥(Secret)使用 Header 里面指定的签名算法（默认是 HMAC SHA256）生成。

  Signature 部分是对前两部分的签名，作用是防止 JWT（主要是 payload） 被篡改。

JWT 通常是这样的：`xxxxx.yyyyy.zzzzz`。

![此图片来源于：https://supertokens.com/blog/oauth-vs-jwt](https://oss.javaguide.cn/javaguide/system-design/jwt/jwt-composition.png)

### jwt如何进行验证

jwt由服务器生成，返回给客户端。以后每次请求客户都携带jwt，服务端检查 JWT 并从中获取用户相关信息。

注意

**请求服务端并携带 JWT 的常见做法是将其放在 HTTP Header 的 `Authorization` 字段中（`Authorization: Bearer Token`）。**

### 如何加强jwt安全性

1. JWT 存放在 localStorage 中而不是 Cookie 中，避免 CSRF 风险。
2. 一定不要将隐私信息存放在 Payload 当中。
3. Payload 要加入 `exp` （JWT 的过期时间），永久有效的 JWT 不合理。并且，JWT 的过期时间不易过长

### JWT的优缺点

1. 无状态：JWT 自身包含了身份验证所需要的所有信息，因此，我们的服务器不需要存储 Session 信息。这显然增加了系统的可用性和伸缩性，大大减轻了服务端的压力。

   但这个也是一个缺点，比如我们想要在 JWT 有效期内废弃一个 JWT 或者更改它的权限的话，并不会立即生效，通常需要等到有效期过后才可以。

2. 有效避免了 CSRF 攻击

3. [适合移动端应用]

4. 单点登录友好

### [注销登录等场景下 JWT 还有效]

**1、将 JWT 存入数据库**

**2、黑名单机制**

**3、保持令牌的有效期限短并经常轮换**

### JWT的续签问题

在 Session 认证中一般的做法：**假如 Session 的有效期 30 分钟，如果 30 分钟内用户有访问，就把 Session 有效期延长 30 分钟。**

解决方法

**用户登录返回两个 JWT**

第一个是 accessJWT ，它的过期时间 就是JWT 本身的过期时间

另外一个是 refreshJWT 它的过期时间更长一点比如为 1 天。refreshJWT 只用来获取 accessJWT，不容易被泄露。

例如

客户端登录后，将 accessJWT 和 refreshJWT 保存在本地，每次访问将 accessJWT 传给服务端。服务端校验 accessJWT 的有效性，如果过期的话，就将 refreshJWT 传给服务端。如果有效，服务端就生成新的 accessJWT 给客户端。否则，客户端就重新登录即可。

**无状态定义**

JWT（JSON Web Tokens）的无状态具体指的是**服务器不需要存储任何关于已发放令牌（token）的状态信息**。这意味着服务器在处理请求时，不会在请求之间保存任何状态信息，每个请求都是独立的，互不影响。因此，每次客户端发送请求时，服务器只需验证JWT的有效性和真实性，而无需访问数据库或其他外部资源来查询令牌的状态或相关信息。这种无状态的设计使得JWT易于扩展和维护，同时也提高了系统的性能和安全性。

另外，JWT的无状态性还体现在令牌本身就是验证令牌持有者授权所需的全部内容。服务器无需咨询令牌颁发服务器以确认其真实性，因为JWT使用数字签名算法进行签名，确保了其真实性和完整性。

### SSO

SSO(Single Sign On)即单点登录说的是用户登陆多个子系统的其中一个就有权访问与其相关的其他系统。

![SSO 示意图](https://oss.javaguide.cn/github/javaguide/system-design/security/sso.png)



SSO好处

**用户角度** :用户能够做到一次登录多次使用，无需记录多套用户名和密码，省心。

**系统管理员角度** : 管理员只需维护好一个统一的账号中心就可以了，方便。

**新系统开发角度:** 新系统开发时只需直接对接统一的账号中心即可，简化开发流程，省时。

