**Spring 最核心的思想就是不重新造轮子，开箱即用，提高开发效率**

## Spring包含的模块

![Spring5.x主要模块](https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/20200831175708.png)

### Core Container

Spring 框架的核心模块，主要提供 IoC 依赖注入功能的支持

**spring-core**：Spring 框架基本的核心工具类。

**spring-beans**：提供对 bean 的创建、配置和管理等功能的支持。

**spring-context**：提供对国际化、事件传播、资源加载等功能的支持。

**spring-expression**：提供对表达式语言（Spring Expression Language） SpEL 的支持，只依赖于 core 模块，不依赖于其他模块，可以单独使用。

### Spring、SpringMVC、SpringBoot之间关系

Spring MVC 是 Spring 中的一个很重要的模块，主要赋予 Spring 快速构建 MVC 架构的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其**核心思想是通过将业务逻辑、数据、显示分离来组织代码**。

![img](https://oss.javaguide.cn/java-guide-blog/image-20210809181452421.png)

使用 Spring 进行开发各种配置过于麻烦比如开启某些 Spring 特性时，需要用 XML 或 Java 进行显式配置。于是，Spring Boot 诞生了！

### SpringMVC架构详解

**模型（Model）**：

- 模型代表应用程序的数据和业务逻辑。
- 在 Spring MVC 中，模型通常由 POJO（Plain Old Java Objects）表示，即普通的 Java 对象。
- 模型对象可以是任何 Java 类，如实体类、数据访问对象（DAO）、服务类等

**视图（View）**：

- 视图负责展示模型数据，并向用户呈现 UI 界面。
- Spring MVC 支持多种视图技术，包括 JSP（JavaServer Pages）、Thymeleaf、FreeMarker 等。
- 视图通常是模板文件，包含展示数据的 HTML、CSS 和 JavaScript 代码。

**控制器（Controller）**：

- 控制器负责接收用户的请求并处理它们。
- 在 Spring MVC 中，控制器通常是由带有 `@Controller` 注解的类表示。
- 控制器中的方法通常用 `@RequestMapping` 或其衍生注解来映射请求的 URL 和 HTTP 方法。
- 控制器负责从请求中提取数据，调用适当的业务逻辑（通常在模型中），然后将结果传递给视图进行渲染。

**Spring MVC 的工作流程如下：**

1. 客户端发送 HTTP 请求到前端控制器（DispatcherServlet）。
2. 前端控制器根据请求信息调用相应的控制器。
3. 控制器处理请求，调用业务逻辑，然后将结果返回给前端控制器。
4. 前端控制器选择适当的视图进行渲染。
5. 将视图返回给客户端，呈现给用户。

### Spring**IoC（Inversion of Control:控制反转）**

这是一种思想而不是技术体现。

IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理

控制反转定义：

- **控制**：指的是对象创建（实例化、管理）的权力
- **反转**：控制权交给外部环境（Spring 框架、IoC 容器）

![IoC 图解](https://oss.javaguide.cn/java-guide-blog/frc-365faceb5697f04f31399937c059c162.png)

在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， I**oC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。**

### SpringBean

Spring 时代我们一般通过 XML 文件来配置 Bean，Springboot通过注解来简化配置

Bean就是被 IoC 容器所管理的对象。

### 将一个类声明为 Bean 的注解有哪些?

- `@Component`：通用的注解，可标注任意类为 `Spring` 组件。
- `@Repository` : 对应持久层即 Dao 层，主要用于数据库相关操作。
- `@Service` : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。
- `@Controller` : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 `Service` 层返回数据给前端页面。

### @Component 和 @Bean 的区别是什么？

- `@Component` 注解作用于类，而`@Bean`注解作用于方法

- `@Component`==通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中==（可以使用 `@ComponentScan` 注解定义要扫描的路径）。

  @bean是将这个方法返回的对象加入到spring容器当中，一般跟@configuration搭配

  当类被`@Configuration`注解标记时，Spring会在容器启动时解析该类，并将其内部的`@Bean`方法返回的对象实例作为bean注册到应用上下文中

- `@Bean` 注解比 `@Component` 注解的自定义性更强，而且很多地方我们只能通过 `@Bean` 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 `Spring`容器时，则只能通过 `@Bean`来实现。

~~~java
//注解相当于在xml中的配置
<beans>
    <bean id="transferService" class="com.acme.TransferServiceImpl"/>
</beans>
~~~

### @Autowired 和 @Resource 的区别是什么？

- `@Autowired` 是 Spring 提供的注解，`@Resource` 是 JDK 提供的注解。

- `Autowired` 默认的注入方式为`byType`（根据类型进行匹配），`@Resource`默认注入方式为 `byName`（根据名称进行匹配）。

- 当一个接口存在多个实现类的情况下，`@Autowired` 和`@Resource`都需要通过名称才能正确匹配到对应的 Bean。`Autowired` 可以通过 `@Qualifier` 注解来显式指定名称，`@Resource`可以通过 `name` 属性来显式指定名称。

  **比如有两个impl实现了service接口，这时想要生效就要**

  ~~~java
  @Autowired
  @Qualifier(value = "smsServiceImpl1")
  private SmsService smsService;
  ~~~

- `@Autowired` 支持在构造函数、方法、字段和参数上使用。`@Resource` 主要用于字段和方法上的注入，不支持在构造函数或参数上使用。

### Bean 的作用域有哪些?

Spring 中 Bean 的作用域通常有下面几种：

作用域定义了bean实例的生命周期以及在应用程序中的可见性

- **singleton** : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是单例设计模式的应用。
- **prototype** : 每次获取都会创建一个新的 bean 实例。
- **request** （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。
- **session** （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。
- **application/global-session** （仅 Web 应用可用）：每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。
- **websocket** （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean

**如何配置 bean 的作用域呢？**

xml方式

~~~java
<bean id="..." class="..." scope="singleton"></bean>
~~~

注解方式

~~~java
@Bean
@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)
public Person personPrototype() {
    return new Person();
}
~~~

### Bean是否是线程安全的

prototype 作用域下，每次获取都会创建一个新的 bean 实例，不存在资源竞争问题，所以不存在线程安全问题。

singleton 作用域下，IoC 容器中只有唯一的 bean 实例，可能会存在资源竞争问题（取决于 Bean 是否有状态）。

有状态 Bean 是指包含可变的成员变量的对象。

例如有一个bean类来保存用户的账号和密码，就是有状态的Bean

对于有状态单例 Bean 的线程安全问题，常见的有两种解决办法：

1. 在 Bean 中尽量避免定义可变的成员变量。
2. 在类中定义一个 `ThreadLocal` 成员变量，将需要的可变成员变量保存在 `ThreadLocal` 中（**推荐的一种方式**）

### Bean的生命周期

1. **创建Bean实例**：由IOC容器找到bean的定义然后通过Java反射API来实现实例

2. **Bean属性填充（依赖注入）**：通过@Autowired注入对象，`@Value` 注入值，或者构造函数注入依赖和值，`@Resource`注入的各种资源等等

3. **Bean初始化**：

   **BeanPostProcessor的预初始化处理（BeanPostProcessor's Pre Initialization Processing）**：Spring会调用注册的BeanPostProcessor来对Bean进行预初始化处理，如AOP代理、属性重写等

   - 如果 Bean 实现了`InitializingBean`接口，执行`afterPropertiesSet()`方法。初始化回调
   - 如果 Bean 在配置文件中的定义包含 `init-method` 属性，执行指定的方法。自定义初始化方法
   - 如果实现了其他 `*.Aware`接口，就调用相应的方法。**`Aware` 接口能让 Bean 能拿到 Spring 容器资源。**

4. **销毁 Bean**：销毁并不是说要立马把 Bean 给销毁掉，而是把 Bean 的销毁方法先记录下来，将来需要销毁 Bean 或者销毁容器的时候，就调用这些方法去释放 Bean 所持有的资源。 

   如果 Bean 实现了 `DisposableBean` 接口，执行 `destroy()` 方法。

   - 如果 Bean 在配置文件中的定义包含 `destroy-method` 属性，执行指定的 Bean 销毁方法。或者，也可以直接通过`@PreDestroy` 注解标记 Bean 销毁之前执行的方法。

**`AbstractAutowireCapableBeanFactory` 的 `doCreateBean()` 方法中能看到依次执行了这 4 个阶段**

~~~java
protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args) {

    // 1. 创建 Bean 的实例
    BeanWrapper instanceWrapper = null;
    if (instanceWrapper == null) {
        instanceWrapper = createBeanInstance(beanName, mbd, args);
    }

    Object exposedObject = bean;
    try {
        // 2. Bean 属性赋值/填充
        populateBean(beanName, mbd, instanceWrapper);
        // 3. Bean 初始化
        exposedObject = initializeBean(beanName, exposedObject, mbd);
    }

    // 4. 销毁 Bean-注册回调接口
    try {
        registerDisposableBeanIfNecessary(beanName, bean, mbd);
    }

    return exposedObject;
}
~~~

`BeanPostProcessor` 接口是 Spring 为修改 Bean 提供的强大扩展点

- `postProcessBeforeInitialization`：Bean 实例化、属性注入完成后，`InitializingBean#afterPropertiesSet`方法以及自定义的 `init-method` 方法之前执行；
- `postProcessAfterInitialization`：类似于上面，不过是在 `InitializingBean#afterPropertiesSet`方法以及自定义的 `init-method` 方法之后执行。

`InitializingBean` 和 `init-method` 是 Spring 为 Bean 初始化提供的扩展点。

![img](https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/spring-bean-lifestyle.png)

### Spring AOP 和AspectJ 的区别

**Spring AOP 属于运行时增强，而 AspectJ 是编译时增强**

### AspectJ 定义的通知类型

- **Before**（前置通知）：目标对象的方法调用之前触发
- **After** （后置通知）：目标对象的方法调用之后触发
- **AfterReturning**（返回通知）：目标对象的方法调用完成，在返回结果值之后触发
- **AfterThrowing**（异常通知）：目标对象的方法运行中抛出 / 触发异常后触发。AfterReturning 和 AfterThrowing 两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。
- **Around** （环绕通知）：编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法

### [说说自己对于 Spring MVC 了解?]

模型(Model)、视图也称表示层(View)、控制器(Controller)的简写,其核心思想是通过将业务逻辑、数据、显示分离来组织代码。

Spring MVC 下我们一般把后端项目分为 Service 层（处理业务）、Dao 层（数据库操作）、Entity 层（实体类）、Controller 层(控制层，返回数据给前台页面)。

### [Spring MVC 的核心组件有哪些？

- **`DispatcherServlet`**：**核心的中央处理器**，负责接收请求、分发，并给予客户端响应。
- **`HandlerMapping`**：**处理器映射器**，根据 URL 去匹配查找能处理的 `Handler`（也就是我们所说的controller） ，并会将请求涉及到的拦截器和 `Handler` 一起封装。
- **`HandlerAdapter`**：**处理器适配器**，根据 `HandlerMapping` 找到的 `Handler` ，适配执行对应的 `Handler`；
- **`Handler`**：**请求处理器**，处理实际请求的处理器。
- **`ViewResolver`**：**视图解析器**，根据 `Handler` 返回的逻辑视图 / 视图，解析并渲染真正的视图，并传递给 `DispatcherServlet` 响应客户端

### 统一异常处理怎么做？

推荐使用注解的方式统一异常处理，具体会使用到 `@ControllerAdvice` + `@ExceptionHandler` 这两个注解

~~~java
@ControllerAdvice
@ResponseBody
public class GlobalExceptionHandler {
    @ExceptionHandler(BaseException.class)
    public ResponseEntity<?> handleAppException(BaseException ex, HttpServletRequest request) {
      //......
    }

    @ExceptionHandler(value = ResourceNotFoundException.class)
    public ResponseEntity<ErrorReponse> handleResourceNotFoundException(ResourceNotFoundException ex, HttpServletRequest request) {
      //......
    }
}
~~~

这种异常处理方式下，会给所有或者指定的 `Controller` 织入异常处理的逻辑（AOP），当 `Controller` 中的方法抛出异常的时候，由被`@ExceptionHandler` 注解修饰的方法进行处理。

`ExceptionHandlerMethodResolver` 中 `getMappedMethod` 方法决定了异常具体被哪个被 `@ExceptionHandler` 注解修饰的方法处理异常。

**`getMappedMethod()`会首先找到可以匹配处理异常的所有方法信息，然后对其进行从小到大的排序，最后取最小的那一个匹配的方法(即匹配度最高的那个)**

### Spring事务

#### 管理事务的方式

- 编程式事务

  在代码中硬编码(在分布式系统中推荐使用) : 通过 `TransactionTemplate`或者 `TransactionManager` 手动管理事务，事务范围过大会出现事务未提交导致超时，因此事务要比锁的粒度更小。

- 声明式事务

  在 XML 配置文件中配置或者直接基于注解（单体应用或者简单业务系统推荐使用） : 实际是通过 AOP 实现（基于`@Transactional` 的全注解方式使用最多）

### [Spring 事务中哪几种事务传播行为?](#spring-事务中哪几种事务传播行为)

事务的传播行为是指：当前事务方法被另一个事务方法调用的时候，需要做什么样的操作

正确的事务传播行为可能的值如下:

1.`TransactionDefinition.PROPAGATION_REQUIRED`

使用的最多的一个事务传播行为，我们平时经常使用的`@Transactional`注解默认使用就是这个事务传播行为。如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。

**`2.TransactionDefinition.PROPAGATION_REQUIRES_NEW`**

创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，`Propagation.REQUIRES_NEW`修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。

**3.`TransactionDefinition.PROPAGATION_NESTED`**

如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于`TransactionDefinition.PROPAGATION_REQUIRED`。

**4.`TransactionDefinition.PROPAGATION_MANDATORY`**

如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）

这个使用的很少。

若是错误的配置以下 3 种事务传播行为，事务将不会发生回滚：

- **`TransactionDefinition.PROPAGATION_SUPPORTS`**: 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。
- **`TransactionDefinition.PROPAGATION_NOT_SUPPORTED`**: 以非事务方式运行，如果当前存在事务，则把当前事务挂起。
- **`TransactionDefinition.PROPAGATION_NEVER`**: 以非事务方式运行，如果当前存在事务，则抛出异常。

嵌套事务允许事务嵌套，但内部事务的提交或回滚不会影响外部事务；而加入事务是在一个事务内部定义的标记点，可以用来实现部分回滚。

### [Spring 事务中的隔离级别有哪几种?](#spring-事务中的隔离级别有哪几种)

和事务传播行为这块一样，为了方便使用，Spring 也相应地定义了一个枚举类：`Isolation`

~~~java
 DEFAULT(TransactionDefinition.ISOLATION_DEFAULT);//使用后端数据库默认的隔离级别，MySQL 默认采用的 REPEATABLE_READ 隔离级别 Oracle 默认采用的 READ_COMMITTED 隔离级别.
    READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED);//读未提交
    READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED);//读提交，会读取别的事务更新操作
    REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ);//可重复读
    SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE);// 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰。只能串行执行
~~~

### Spring Data JPA

Spring Data JPA 的主要目标是简化数据访问层的开发，提供了一组通用的接口和类，可以减少开发人员编写重复的数据访问代码

#### 使用JPA非持久化数据

@Transient，一般使用注解方式

#### JPA的审计功能

审计功能主要是帮助我们记录数据库操作的具体行为比如某条记录是谁创建的、什么时间创建的、最后修改人是谁、最后修改时间是什么时候。

可以使用mybatis的配置使用

也可以搭配注解

`@CreatedDate`: 表示该字段为创建时间字段，在这个实体被 insert 的时候，会设置值

`@CreatedBy` :表示该字段为创建人，在这个实体被 insert 的时候，会设置值

`@LastModifiedDate`、`@LastModifiedBy`同理。

### SpringIOC&AOP

IoC 最常见以及最合理的实现方式叫做依赖注入（Dependency Injection，简称 DI

### AOP

AOP（Aspect Oriented Programming）即面向切面编程，通过将一些横切的关注点从业务逻辑中抽离出来，以便更好的维护和管理代码，横切关注点通常包括日志记录，事务管理等公共行为。

是oop的一种延续

然后aop包含几个核心的概念就是

<img src="C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20231129164034307.png" alt="image-20231129164034307" style="zoom:80%;" />

- **横切关注点（cross-cutting concerns）** ：多个类或对象中的公共行为（如日志记录、事务管理、权限控制、接口限流、接口幂等等）。
- **切面（Aspect）**：对横切关注点进行封装的类，包含一组通知和切点的定义。
- **连接点（JoinPoint）：** 连接点是在应用程序执行过程中可以插入切面的点，比如方法调用、方法执行、异常处理等。具体执行点
- **通知（Advice）**： 通知定义了在连接点何时、何地执行的行为。常见的通知类型包括前置通知（Before advice）、后置通知（After advice）、返回通知（After-returning advice）、异常通知（After-throwing advice）和环绕通知（Around advice）等
- **切点（Pointcut）**：切点是连接点的一个子集，它定义了何处应用通知。通过表达式或者正则表达式等方式，可以指定一组满足条件的连接点作为切点。
- **织入（Weaving）**：织入是将切面和目标对象连接起来的过程，也就是将通知应用到切点匹配的连接点上。常见的织入时机有两种，分别是编译期织入（AspectJ）和运行期织入（AspectJ）

OOP 不能很好地处理一些分散在多个类或对象中的公共行为（如日志记录、事务管理、权限控制、接口限流、接口幂等等），这些行为通常被称为 **横切关注点（cross-cutting concerns）** 。如果我们在每个类或对象中都重复实现这些行为，那么会导致代码的冗余、复杂和难以维护

<img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/crosscut-logic-and-businesslogic-separation%20%20%20%20%20%20.png" alt="img" style="zoom:67%;" />

### AOP实现方式

<img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/230ae587a322d6e4d09510161987d346.jpeg" alt="SpringAOPProcess" style="zoom:67%;" />

实现了某个接口，那么 Spring AOP 会使用 **JDK Proxy**，去创建代理对象

没有实现接口的对象，Spring AOP 会使用 **Cglib** 生成一个被代理对象的子类来作为代理

这个是利用aop技术的实现

先定义一个注解，这个注解相当于标记切入点

然后定义切面类，切面类中定义切入点和增强方阿飞

~~~java

// 日志注解
@Target({ElementType.PARAMETER,ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Log {

    /**
     * 描述
     */
    String description() default "";

    /**
     * 方法类型 INSERT DELETE UPDATE OTHER
     */
    MethodType methodType() default MethodType.OTHER;
}

// 日志切面
@Component
@Aspect
public class LogAspect {
  // 切入点，所有被 Log 注解标注的方法
  @Pointcut("@annotation(cn.javaguide.annotation.Log)")
  public void webLog() {
  }

   /**
   * 环绕通知
   */
  @Around("webLog()")
  public Object doAround(ProceedingJoinPoint joinPoint) throws Throwable {
    // 省略具体的处理逻辑
  }

  // 省略其他代码
}
~~~

~~~java
@Log(description = "method1",methodType = MethodType.INSERT)
public CommonResponse<Object> method1() {
      // 业务逻辑
      xxService.method1();
      // 省略具体的业务处理逻辑
      return CommonResponse.success();
}

~~~

## Spring事务

**MySQL 怎么保证原子性的**，如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行**回滚**，MySQL有undo log，并且，回滚日志会先于数据持久化到磁盘上。

事务支持有编程式事务（手动代码开启）和声明式事务（注解）

### Spring事务管理接口介绍

- **`PlatformTransactionManager`**：（平台）事务管理器，Spring 事务策略的核心。
- **`TransactionDefinition`**：事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)。
- **`TransactionStatus`**：事务运行状态

**`PlatformTransactionManager`** 接口可以被看作是事务上层的管理者，而 **`TransactionDefinition`** 和 **`TransactionStatus`** 这两个接口可以看作是事务的描述

**Spring 并不直接管理事务，而是提供了多种事务管理器** 。Spring 事务管理器的接口是：**`PlatformTransactionManager`**。

通过这个接口，Spring 为各个平台如：JDBC(`DataSourceTransactionManager`)、Hibernate(`HibernateTransactionManager`)、JPA(`JpaTransactionManager`)等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情

为什么要抽象出来这个接口

**主要是因为要将事务管理行为抽象出来，然后不同的平台去实现它，这样我们可以保证提供给外部的行为不变，方便我们扩展**

事务属性有

- 隔离级别

- 传播行为（**解决业务层方法之间互相调用的事务问题**）

  常用有**`PROPAGATION_REQUIRED`**，**`PROPAGATION_REQUIRES_NEW`**，**`PROPAGATION_NESTED`**

- 回滚规则

- 是否只读

- 事务超时

**事务传播行为是为了解决业务层方法之间互相调用的事务问题**

#### [`@Transactional` 的作用范围]

- **方法**：推荐将注解使用于方法上，不过需要注意的是：**该注解只能应用到 public 方法上，否则不生效。**
- **类**：如果这个注解使用在类上的话，表明该注解对该类中所有的 public 方法都生效。
- **接口**：不推荐在接口上使用。

#### [`@Transactional` 事务注解原理](https://javaguide.cn/system-design/framework/spring/spring-transaction.html#transactional-事务注解原理)

如果一个类或者一个类中的 public 方法上被标注`@Transactional` 注解的话，Spring 容器就会在启动的时候为其创建一个代理类，在调用被`@Transactional` 注解的 public 方法的时候，实际调用的是，`TransactionInterceptor` 类中的 `invoke()`方法。这个方法的作用就是在目标方法之前开启事务，方法执行过程中如果遇到异常的时候回滚事务，方法调用完成之后提交事务。

> `TransactionInterceptor` 类中的 `invoke()`方法内部实际调用的是 `TransactionAspectSupport` 类的 `invokeWithinTransaction()`方法。由于新版本的 Spring 对这部分重写很大，而且用到了很多响应式编程的知识，这里就不列源码了

SpringAOP自调用会失效

~~~java
@Service
public class MyService {

private void method1() {
     method2();
     //......
}
@Transactional
 public void method2() {
     //......
  }
}
~~~

#### [`@Transactional` 的使用注意事项总结](#transactional-的使用注意事项总结)

- `@Transactional` 注解只有作用到 public 方法上事务才生效，不推荐在接口上使用；
- 避免同一个类中调用 `@Transactional` 注解的方法，这样会导致事务失效；
- 正确的设置 `@Transactional` 的 `rollbackFor` 和 `propagation` 属性，否则事务可能会回滚失败;
- 被 `@Transactional` 注解的方法所在的类必须被 Spring 管理，否则不生效；
- 底层使用的数据库必须支持事务机制，否则不生效；

#### Spring 框架中用到了哪些设计模式？

- **工厂设计模式** : Spring 使用工厂模式通过 `BeanFactory`、`ApplicationContext` 创建 bean 对象。
- **代理设计模式** : Spring AOP 功能的实现。
- **单例设计模式** : Spring 中的 Bean 默认都是单例的。
- **模板方法模式** : Spring 中 `jdbcTemplate`、`hibernateTemplate` 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。
- **包装器设计模式** : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。
- **观察者模式:** Spring 事件驱动模型就是观察者模式很经典的一个应用。
- **适配器模式** :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配`Controller`。

Spring Boot 自动装配原理

Spring Boot 通过`@EnableAutoConfiguration`开启自动装配，通过 SpringFactoriesLoader 最终加载`META-INF/spring.factories`中的自动配置类实现自动装配，自动配置类其实就是通过`@Conditional`按需加载的配置类，想要其生效必须引入`spring-boot-starter-xxx`包实现起步依赖

自动装配可以简单理解为：**通过注解或者一些简单的配置就能在 Spring Boot 的帮助下实现某块功能**
