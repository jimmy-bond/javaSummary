操作系统本质上是一个运行在计算机上的软件程序 ，主要用于管理计算机硬件和软件资源

操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性

应用通过内核进行系统调用来操作硬件

![Kernel_Layout](https://oss.javaguide.cn/2020-8/Kernel_Layout.png)

### 用户态和内核态

- **用户态(User Mode)** : 用户态运行的进程可以直接读取用户程序的数据，拥有较低的权限
- **内核态(Kernel Mode)**：内核态运行的进程几乎可以访问计算机的任何资源包括系统的内存空间、设备、驱动程序等，不受限制，拥有非常高的权限

同时具有用户态和内核态主要是为了保证计算机系统的安全性、稳定性和性能

只能由操作系统内核态执行的指令叫做 **特权指令** 

如果只有内核态，那么所有程序或进程都必须共享系统资源，例如内存、CPU、硬盘等，这将导致系统资源的竞争和冲突，从而影响系统性能和效率

### 用户态和内核态的切换方式

![用户态切换到内核态的 3 种方式](https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/the-way-switch-between-user-mode-and-kernel-mode.drawio.png)

系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现

中断和异常类似，都是通过中断向量表来找到相应的处理程序进行处理。区别在于，**中断来自处理器外部**，而异常是执行当前指令的结果

### 系统调用

要进行系统级别的资源调动需要进行系统调用

系统调用按功能大致可分为如下几类：

- 设备管理：完成设备（输入输出设备和外部存储设备等）的请求或释放，以及设备启动等功能。
- 文件管理：完成文件的读、写、创建及删除等功能。
- 进程管理：进程的创建、撤销、阻塞、唤醒，进程间的通信等功能。
- 内存管理：完成内存的分配、回收以及获取作业占用内存区大小及地址等功能

### 系统调用过程

1. 用户态的程序发起系统调用，程序权限不足，因此会中断执行，也就是 Trap
2. 发生中断后，当前 CPU 执行的程序会中断，跳转到中断处理程序。内核程序开始执行，也就是开始处理系统调用
3. 内核处理完成后，主动触发 Trap，这样会再次发生中断，切换回用户态工作

![系统调用的过程](https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/system-call-procedure.png)

### 线程同步方式

- 互斥锁：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限
- 读写锁：对资源的操作
- 信号量：允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。
- 屏障：用于等待多个线程到达某个点再执行
- 事件：通过通知操作的方式来同步线程操作

### PCB（进程控制块）

用来管理和跟踪进程的数据结构

每个进程都有一个独立PID和PCB，都在进程创建的时候赋予

#### PCB组成

- 进程标识符(PID)父进程表示符
- 进程的运行状态
- 进程的寄存器集合
- 进程的优先级
- 进程的资源使用情况
- 进程打开的文件信息，包括文件描述符、文件类型、打开模式等等
- **进程控制信息（Process Control Information）：** 包括进程状态、进程创建时间、CPU 时间片使用情况等控制信息

### 进程通信方式

- 管道通信
- 信号量：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件
- 消息队列：**消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺点。**
- 套接字：此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元

### 进程调度算法

![常见进程调度算法](https://oss.javaguide.cn/github/javaguide/cs-basics/network/scheduling-algorithms-of-process.png)

多级反馈队列：既能使高优先级的作业得到响应又能使短作业（进程）迅速完成

当一个进程调用 exit()系统调用结束自己的生命时，内核会释放该进程的所有资源，包括打开的文件、占用的内存等，但是该进程对应的 PCB 依然存在于系统中。这些信息只有在父进程调用 wait()或 waitpid()系统调用时才会被释放，以便让父进程得到子进程的状态信息。

**僵尸进程**：子进程已经终止，但是其父进程仍在运行，且父进程没有调用 wait()或 waitpid()等系统调用来获取子进程的状态信息，释放子进程占用的资源，导致子进程的 PCB 依然存在于系统中，但无法被进一步使用。

**孤儿进程**：一个进程的父进程已经终止或者不存在，但是该进程仍在运行。操作系统会将孤儿进程的父进程设置为 init 进程（进程号为 1），由 init 进程来回收孤儿进程的资源

查看僵尸进程

Linux 下可以使用 Top 命令查找，`zombie` 值表示僵尸进程的数量，为 0 则代表没有僵尸进程。

### 预防死锁策略

**静态分配策略**：破坏占有且等待条件，就是指一个进程必须在执行前就申请到它所需要的全部资源

**层次分配策略**：破坏循环等待，在层次分配策略下，所有的资源被分成了多个层次，一个进程得到某一次的一个资源后，它只能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源，按这种策略，是不可能出现循环等待链的，因为那样的话，就出现了已经申请了较高层的资源，反而去申请了较低层的资源，不符合层次分配策略

### 银行家算法

我们将系统的状态分为 **安全状态** 和 **不安全状态** ，每当在为申请者分配资源前先测试系统状态，若把系统资源分配给申请者会产生死锁，则拒绝分配，否则接受申请，并为它分配资源

### 死锁检测

用资源分配图来显示

![进程-资源分配图](https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/process-resource-allocation-diagram.jpg)

### 内存管理

![内存管理主要做的事情](https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/memory-management-roles.png)

- 内存分配与回收malloc 函数：申请内存，free 函数：释放内存
- 地址转换：将虚拟地址转换为内存真实地址
- **内存扩充**：当系统没有足够的内存时，利用虚拟内存技术或自动覆盖技术，从逻辑上扩充内存
- **内存映射**：将一个文件直接映射到进程的进程空间中，这样可以通过内存指针用读写内存的办法直接存取文件内容，速度更快

### 内存碎片

![内存碎片](https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/internal-and-external-fragmentation.png)

内存管理方式可以简单分为下面两种：

- **连续内存管理**：为一个用户程序分配一个连续的内存空间，内存利用率一般不高。

  **伙伴系统（Buddy System）算法** ：将内存按 2 的幂次划分（每一块内存大小都是 2 的幂次比如 2^6=64 KB），并将相邻的内存块组合成一对伙伴，但会产生内部碎片

  可以用来解决外部碎片

- **非连续内存管理**：允许一个程序使用的内存分布在离散或者说不相邻的内存中

  **段式管理**：以段(—段连续的物理内存)的形式管理/分配物理内存。应用程序的虚拟地址空间被分为大小不等的段

​		**页式管理**：把物理内存分为连续等长的物理页

​		**段页式管理机制**：结合了段式管理和页式管理的一种内存管理机制，把物理内存先分成若干段，每个段又继续分成若干大小相等的页

### 虚拟内存

逻辑存在，作为进程访问主存（物理内存）的桥梁并简化内存管理![虚拟内存作为进程访问主存的桥梁](https://oss.javaguide.cn/xingqiu/virtual-memory.png)

- 隔离进程：每个都有自己的虚拟空间，进程之间不能互相干扰
- 简化内存管理：只需要管理进程，不需要操作物理内存
- 多个进程共享物理内存：进程在运行过程中，会加载许多操作系统的动态库。这些库对于每个进程而言都是公用的，它们在内存中实际只会加载一份，这部分称为共享内存
- **提高内存使用安全性**：控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性。
- **提供更大的可使用内存空间**：可以让程序拥有超过系统物理内存大小的可用内存空间。这是因为当物理内存不够用时，可以利用磁盘充当，将物理内存页（通常大小为 4 KB）保存到磁盘文件（会影响读写速度），数据或代码页会根据需要在物理内存与磁盘之间移动

### 虚拟地址和物理地址

操作系统一般通过 CPU 芯片中的一个重要组件 **MMU(Memory Management Unit，内存管理单元)** 将虚拟地址转换为物理地址，这个过程被称为 **地址翻译/地址转换**

![地址翻译过程](https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/physical-virtual-address-translation.png)

- 虚拟地址空间是虚拟地址的集合，是虚拟内存的范围。每一个进程都有一个一致且私有的虚拟地址空间。
- 物理地址空间是物理地址的集合，是物理内存的范围

#### MMU有分页机制和分段机制

##### 分段机制

分段管理通过 **段表（Segment Table）** 映射虚拟地址和物理地址

分段机制下的虚拟地址由两部分组成：

- **段号**：标识着该虚拟地址属于整个虚拟地址空间中的哪一个段。
- **段内偏移量**：相对于该段起始地址的偏移量

![分段机制下的地址翻译过程](https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/segment-virtual-address-composition.png)

分段机制会导致外部碎片

![分段机制导致外部内存碎片](https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/segment-external-memory-fragmentation.png)

##### 分页机制

**这里的页是连续等长的，不同于分段机制下不同长度的段**

单级页表

<img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/page-table.png" alt="单级页表" style="zoom: 67%;" />

分页机制下的虚拟地址由两部分组成：

- **页号**：通过虚拟页号可以从页表中取出对应的物理页号；
- **页内偏移量**：物理页起始地址+页内偏移量=物理内存地址

<img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/paging-virtual-address-composition.png" alt="分页机制下的地址翻译过程" style="zoom: 67%;" />

### 多级页表的出现

32位的，虚拟地址有2^32^ （4GB）大小，一个页大小为4KB（2^12^ ）,既有2^20^ 个页表项，一个页表项大小为4字节

一个程序啥都不干，页表大小就得占用 4M

为了解决这个问题，操作系统引入了 **多级页表** ，多级页表对应多个页表，每个页表也前一个页表相关联

一级页表共有 1024 个页表项，一级页表又关联二级页表，二级页表同样共有 1024 个页表项。二级页表中的一级页表项是一对多的关系，二级页表按需加载（只会用到很少一部分二级页表），进而节省空间占用

<img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/multilevel-page-table.png" alt="多级页表" style="zoom:67%;" />

只需要 2 个二级页表，那两级页表的内存占用情况为: 4KB（一级页表占用） + 4KB * 2（二级页表占用） = 12 KB

### TLB快表

提高虚拟地址到物理地址的转换速度

![使用 TLB 之后的地址翻译流程](https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/page-table-tlb.png)

### 换页机制

当物理内存不够用的时候，操作系统选择将一些物理页的内容放到磁盘上去，等要用到的时候再将它们读取到物理内存中。也就是说，换页机制利用磁盘这种较低廉的存储设备扩展的物理内存

### 页缺失

当软件试图访问已映射在虚拟地址空间中，但是目前并未被加载在物理内存中的一个分页时，由 MMU 所发出的中断

### 页面置换算法

![常见的页面置换算法](https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/image-20230409113009139.png)

### 局部性原理

时间局部性：

将最近访问的一些页加入缓存中，提高缓存命中率

为了利用时间局部性，分页机制中通常采用缓存机制来提高页面的命中率，即将最近访问过的一些页放入缓存中，如果下一次访问的页已经在缓存中，就不需要再次访问内存，而是直接从缓存中读取

空间局部性：提前加载访问页的一些相邻页

### 文件系统

主要功能：

- 存储管理
- 文件管理：文件的创建，删除，移动
- 目录管理：目录的创建，删除，移动
- 文件访问权限控制：根据访问用户的权限判定是否能访问

### 硬链接和软链接

#### 硬链接

- 在 Linux/类 Unix 文件系统中，每个文件和目录都有一个唯一的索引节点（inode）号，用来标识该文件或目录。硬链接通过 inode 节点号建立连接，硬链接和源文件的 inode 节点号相同，两者对文件系统来说是完全平等的（可以看作是互为硬链接，源头是同一份文件），删除其中任何一个对另外一个没有影响，可以通过给文件设置硬链接文件来防止重要文件被误删

- `ln` 命令用于创建硬链接

- 不能跨越文件系统

  因为不同的系统inode表格不一样

#### 软链接

- 软链接和源文件的 inode 节点号不同，而是指向一个文件路径。
- 源文件删除后，软链接依然存在，但是指向的是一个无效的文件路径

- `ln -s` 命令用于创建软链接。
- 软链接可以跨越文件系统

### 磁盘调度算法

操作系统中对磁盘访问请求进行排序和调度的算法，其目的是提高磁盘的访问效率

![常见的磁盘调度算法](https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/disk-scheduling-algorithms.png)

**扫描算法（SCAN）**：也被称为电梯（Elevator）算法，基本思想和电梯非常类似。磁头沿着一个方向扫描磁盘，如果经过的磁道有请求就处理，直到到达磁盘的边界，然后改变移动方向，依此往复

**循环扫描算法（Circular Scan，C-SCAN）**：SCAN 算法的变体，只在磁盘的一侧进行扫描，并且只按照一个方向扫描，直到到达磁盘边界，然后回到磁盘起点，重新开始循环