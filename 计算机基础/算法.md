### 排序算法分类

十种常见排序算法可以分类两大类别：**比较类排序**和**非比较类排序**

<img src="https://oss.javaguide.cn/github/javaguide/cs-basics/sorting-algorithms/sort2.png" alt="排序算法分类" style="zoom: 33%;" />

### 冒泡排序

![冒泡排序](https://oss.javaguide.cn/github/javaguide/cs-basics/sorting-algorithms/bubble_sort.gif)

每次循环两两比较确定一个元素

- **稳定性**：稳定
- **时间复杂度**：最佳：𝑂(𝑛) ，最差：𝑂(𝑛2)， 平均：𝑂(𝑛2)
- **空间复杂度**：𝑂(1)

### 选择排序

![Selection Sort](https://oss.javaguide.cn/github/javaguide/cs-basics/sorting-algorithms/selection_sort.gif)

1. 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
3. 重复第 2 步，直到所有元素均排序完毕。

- **稳定性**：不稳定
- **时间复杂度**：最佳：𝑂(𝑛2) ，最差：𝑂(𝑛2)， 平均：𝑂(𝑛2)
- **空间复杂度**：O(1)

### 插入排序

- 从第一个元素开始，该元素可以认为已经被排序；
- 取出下一个元素，在已经排序的元素序列中从后向前扫描；
- 如果该元素（已排序）大于新元素，将该元素移到下一位置；
- 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；
- 将新元素插入到该位置后；
- 重复步骤 2~5



![insertion_sort](https://oss.javaguide.cn/github/javaguide/cs-basics/sorting-algorithms/insertion_sort.gif)

### 希尔排序

希尔排序也是一种插入排序。先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录 “基本有序” 时，再对全体记录进行依次直接插入排序

在此我们选择增量 𝑔𝑎𝑝=𝑙𝑒𝑛𝑔𝑡ℎ/2，缩小增量继续以 𝑔𝑎𝑝=𝑔𝑎𝑝/2 的方式，这种增量选择我们可以用一个序列来表示，{𝑛2,(𝑛/2)2,…,1}，称为**增量序列**。

![shell_sort](https://oss.javaguide.cn/github/javaguide/cs-basics/sorting-algorithms/shell_sort.png)

~~~java
/**
 * 希尔排序
 */
public static int[] shellSort(int[] arr) {
    int n = arr.length;
    int gap = n / 2;
    while (gap > 0) {
        for (int i = gap; i < n; i++) {
            int current = arr[i];
            int preIndex = i - gap;
            // Insertion sort
            while (preIndex >= 0 && arr[preIndex] > current) {
                arr[preIndex + gap] = arr[preIndex];
                preIndex -= gap;
            }
            arr[preIndex + gap] = current;

        }
        gap /= 2;
    }
    return arr;
}
~~~

- **稳定性**：不稳定
- **时间复杂度**：最佳：𝑂(𝑛𝑙𝑜𝑔𝑛)， 最差：𝑂(𝑛2) 平均：𝑂(𝑛𝑙𝑜𝑔𝑛)
- **空间复杂度**：`O(1)`

## [归并排序 (Merge Sort)](https://javaguide.cn/cs-basics/algorithms/10-classical-sorting-algorithms.html#归并排序-merge-sort)

将已有序的子序列合并，得到完全有序的序列

和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 𝑂(𝑛𝑙𝑜𝑔𝑛) 的时间复杂度。代价是需要额外的内存空间

归并排序算法是一个递归过程，边界条件为当输入序列仅有一个元素时，直接返回，具体过程如下：

1. 如果输入内只有一个元素，则直接返回，否则将长度为 n 的输入序列分成两个长度为 n/2 的子序列；
2. 分别对这两个子序列进行归并排序，使子序列变为有序状态；
3. 设定两个指针，分别指向两个已经排序子序列的起始位置；
4. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间（用于存放排序结果），并移动指针到下一位置；
5. 重复步骤 3 ~ 4 直到某一指针达到序列尾；
6. 将另一序列剩下的所有元素直接复制到合并序列尾

![MergeSort](https://oss.javaguide.cn/github/javaguide/cs-basics/sorting-algorithms/merge_sort.gif)

~~~java
//归并排序
/**
 * 归并排序
 *
 * @param arr
 * @return arr
 */
public static int[] mergeSort(int[] arr) {
    if (arr.length <= 1) {
        return arr;
    }
    int middle = arr.length / 2;
    int[] arr_1 = Arrays.copyOfRange(arr, 0, middle);
    int[] arr_2 = Arrays.copyOfRange(arr, middle, arr.length);
    return merge(mergeSort(arr_1), mergeSort(arr_2));
}

/**
 * Merge two sorted arrays
 *
 * @param arr_1
 * @param arr_2
 * @return sorted_arr
 */
public static int[] merge(int[] arr_1, int[] arr_2) {
    int[] sorted_arr = new int[arr_1.length + arr_2.length];
    int idx = 0, idx_1 = 0, idx_2 = 0;
    while (idx_1 < arr_1.length && idx_2 < arr_2.length) {
        if (arr_1[idx_1] < arr_2[idx_2]) {
            sorted_arr[idx] = arr_1[idx_1];
            idx_1 += 1;
        } else {
            sorted_arr[idx] = arr_2[idx_2];
            idx_2 += 1;
        }
        idx += 1;
    }
    if (idx_1 < arr_1.length) {
        while (idx_1 < arr_1.length) {
            sorted_arr[idx] = arr_1[idx_1];
            idx_1 += 1;
            idx += 1;
        }
    } else {
        while (idx_2 < arr_2.length) {
            sorted_arr[idx] = arr_2[idx_2];
            idx_2 += 1;
            idx += 1;
        }
    }
    return sorted_arr;
}

~~~

- **稳定性**：稳定
- **时间复杂度**：最佳：𝑂(𝑛𝑙𝑜𝑔𝑛)， 最差：𝑂(𝑛𝑙𝑜𝑔𝑛)， 平均：𝑂(𝑛𝑙𝑜𝑔𝑛)
- **空间复杂度**：𝑂(𝑛)

## 快速排序

![RandomQuickSort](https://oss.javaguide.cn/github/javaguide/cs-basics/sorting-algorithms/random_quick_sort.gif)

~~~java
public static int partition(int[] array, int low, int high) {
    int pivot = array[high];
    int pointer = low;
    for (int i = low; i < high; i++) {
        if (array[i] <= pivot) {
            int temp = array[i];
            array[i] = array[pointer];
            array[pointer] = temp;
            pointer++;
        }
        System.out.println(Arrays.toString(array));
    }
    int temp = array[pointer];
    array[pointer] = array[high];
    array[high] = temp;
    return pointer;
}
public static void quickSort(int[] array, int low, int high) {
    if (low < high) {
        int position = partition(array, low, high);
        quickSort(array, low, position - 1);
        quickSort(array, position + 1, high);
    }
}
~~~

#### 算法分析

- **稳定性**：不稳定
- **时间复杂度**：最佳：𝑂(𝑛𝑙𝑜𝑔𝑛)， 最差：𝑂(𝑛𝑙𝑜𝑔𝑛)，平均：𝑂(𝑛𝑙𝑜𝑔𝑛)
- **空间复杂度**：𝑂(𝑙𝑜𝑔𝑛)

## 堆排序 

堆是一个近似完全二叉树的结构，并同时满足**堆的性质**：即**子结点的值总是小于（或者大于）它的父节点**

![HeapSort](https://oss.javaguide.cn/github/javaguide/cs-basics/sorting-algorithms/heap_sort.gif)

# -----------------------------------



